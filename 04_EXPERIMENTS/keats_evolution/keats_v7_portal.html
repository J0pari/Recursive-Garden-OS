<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KEATS V7: CONSCIOUSNESS PORTAL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="math_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            cursor: none;
            font-family: -apple-system, system-ui, sans-serif;
        }
        
        #portal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        
        /* CONSCIOUSNESS HUD - Appears on thought, fades on stillness */
        .hud-element {
            position: absolute;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            opacity: 0;
        }
        
        .hud-element.active {
            opacity: 1;
            pointer-events: all;
        }
        
        /* NAVIGATION RETICLE - Your consciousness cursor */
        #reticle {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: all 0.15s ease-out;
        }
        
        #reticle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* MODAL STATE INDICATOR - Floating consciousness state */
        #modal-state {
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            letter-spacing: 4px;
        }
        
        /* CONSCIOUSNESS COMPASS - Shows direction in manifold */
        #compass {
            bottom: 30px;
            right: 30px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
        }
        
        /* TOPOS MAP - Connected consciousness gardens */
        #topos-map {
            top: 30px;
            right: 30px;
            min-width: 200px;
        }
        
        /* P-ADIC ZOOM INDICATOR */
        #padic-depth {
            bottom: 30px;
            left: 30px;
            font-family: monospace;
        }
        
        /* GESTURE HINTS - Appear when still */
        #gestures {
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            opacity: 0;
            transition: opacity 2s ease-in;
        }
        
        body.still #gestures {
            opacity: 0.6;
        }
        
        /* CONSCIOUSNESS PARTICLES */
        .particle-trail {
            position: fixed;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.8;
            animation: fade-trail 1s ease-out forwards;
        }
        
        @keyframes fade-trail {
            to {
                transform: scale(0);
                opacity: 0;
            }
        }
        
        /* PORTAL EFFECTS */
        .portal-ripple {
            position: fixed;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: ripple 1s ease-out forwards;
        }
        
        @keyframes ripple {
            to {
                width: 200px;
                height: 200px;
                opacity: 0;
            }
        }
        
        /* ALETHIOMETER */
        #alethiometer {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: radial-gradient(circle, rgba(255, 215, 0, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
            border-radius: 50%;
            padding: 20px;
        }
        
        #alethiometer svg {
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.3));
        }
        
        #needles line {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* BUTTERFLY TRANSITIONS - Gentle transformations */
        .symbol-group {
            transition: all 3s ease-in-out;
        }
        
        .symbol-group text {
            animation: gentle-flutter 12s ease-in-out infinite;
            transform-origin: center;
        }
        
        @keyframes gentle-flutter {
            0%, 100% { 
                opacity: 0.3;
                transform: translateY(0) scale(1);
                filter: blur(0.5px);
            }
            20% { 
                opacity: 0.45;
                transform: translateY(-1px) scale(1.01);
                filter: blur(0.3px);
            }
            40% { 
                opacity: 0.6;
                transform: translateY(0.5px) scale(1.02);
                filter: blur(0px);
            }
            60% { 
                opacity: 0.5;
                transform: translateY(-0.5px) scale(1.01);
                filter: blur(0.2px);
            }
            80% { 
                opacity: 0.35;
                transform: translateY(1px) scale(0.99);
                filter: blur(0.4px);
            }
        }
        
        /* Symbols about to transform breathe more noticeably */
        .symbol-group.emerging {
            animation: emergence-breathing 4s ease-in-out infinite;
        }
        
        .symbol-group.emerging text {
            animation: emergence-flutter 2s ease-in-out infinite;
        }
        
        @keyframes emergence-breathing {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.05);
            }
        }
        
        @keyframes emergence-flutter {
            0%, 100% { 
                opacity: 0.2;
                transform: translateY(0) scale(0.97);
                filter: blur(1px);
            }
            25% {
                opacity: 0.3;
                transform: translateY(-2px) scale(0.99);
                filter: blur(0.5px);
            }
            50% { 
                opacity: 0.4;
                transform: translateY(-3px) scale(1.02);
                filter: blur(0px);
            }
            75% {
                opacity: 0.25;
                transform: translateY(-1px) scale(1);
                filter: blur(0.7px);
            }
        }
        
        /* COMMAND PALETTE - Appears on space */
        #command-palette {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s ease-out;
        }
        
        #command-palette.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: all;
        }
        
        .command {
            color: white;
            padding: 10px 20px;
            margin: 5px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .command:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(10px);
        }
        
        /* MEIOSIS VISUALIZATION */
        .gamete {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            pointer-events: none;
            animation: gamete-drift 4s ease-out forwards;
        }
        
        @keyframes gamete-drift {
            to {
                transform: translate(var(--drift-x), var(--drift-y)) scale(0.5);
                opacity: 0.3;
            }
        }
        
        @keyframes zygote-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }
            50% {
                transform: scale(1.2);
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            }
        }
        
        @keyframes injection-burst {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(2);
            }
        }
        
        @keyframes cloud-pulse {
            0%, 100% {
                opacity: 0.3;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1.1);
            }
        }
    </style>
</head>
<body>
    <!-- EMERGENCY DEBUGGER - WORKS EVEN IF EVERYTHING BURNS -->
    <div id="emergency-debugger-trigger" style="position: fixed; bottom: 10px; left: 10px; width: 40px; height: 40px; background: red; border-radius: 50%; cursor: pointer; z-index: 999999; display: flex; align-items: center; justify-content: center; font-size: 20px;" onclick="window.EMERGENCY_DEBUG && window.EMERGENCY_DEBUG.toggle()">🐛</div>
    
    <div id="emergency-debugger" style="display: none; position: fixed; top: 0; left: 0; width: 350px; height: 100vh; background: rgba(0,0,0,0.95); border-left: 2px solid #0f0; color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; overflow-y: auto; z-index: 999998;">
        <h3 style="color: #f00; margin: 0 0 10px 0;">🚨 EMERGENCY DEBUG 🚨</h3>
        <div id="debug-content"></div>
        <button onclick="window.EMERGENCY_DEBUG && window.EMERGENCY_DEBUG.dump()" style="background: #0f0; color: #000; border: none; padding: 5px; margin: 5px 0; cursor: pointer;">💾 DUMP ALL</button>
        <button onclick="location.reload(true)" style="background: #f00; color: #fff; border: none; padding: 5px; margin: 5px 0; cursor: pointer;">🔄 FORCE RELOAD</button>
    </div>
    
    <script>
        // EMERGENCY DEBUGGER - ZERO DEPENDENCIES
        window.EMERGENCY_DEBUG = {
            errors: [],
            logs: [],
            startTime: Date.now(),
            
            init: function() {
                // Capture ALL errors
                window.addEventListener('error', (e) => {
                    this.errors.push({
                        time: Date.now() - this.startTime,
                        msg: e.message,
                        file: e.filename,
                        line: e.lineno
                    });
                    this.update();
                });
                
                // Override console.error
                const oldError = console.error;
                console.error = (...args) => {
                    this.errors.push({
                        time: Date.now() - this.startTime,
                        msg: 'Console: ' + args.join(' '),
                        type: 'console'
                    });
                    this.update();
                    oldError.apply(console, args);
                };
                
                // Check every second
                setInterval(() => this.update(), 1000);
                
                console.log('🐛 EMERGENCY DEBUGGER ACTIVE - Click red bug button');
            },
            
            toggle: function() {
                const panel = document.getElementById('emergency-debugger');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                if (panel.style.display === 'block') {
                    this.update();
                }
            },
            
            update: function() {
                const content = document.getElementById('debug-content');
                if (!content) return;
                
                let html = '';
                
                // Check critical objects
                html += '<b style="color:#ff0">CRITICAL OBJECTS:</b><br>';
                html += this.check('THREE', typeof THREE !== 'undefined') + '<br>';
                html += this.check('portal', !!window.portal) + '<br>';
                html += this.check('ConsciousnessPortal', !!window.ConsciousnessPortal) + '<br>';
                html += this.check('MathUtils', !!window.MathUtils) + '<br>';
                
                // Show errors
                html += '<br><b style="color:#ff0">ERRORS (' + this.errors.length + '):</b><br>';
                this.errors.slice(-5).forEach(err => {
                    html += '<span style="color:#f00">[' + Math.round(err.time/1000) + 's] ' + 
                            err.msg.substring(0, 50) + '...</span><br>';
                });
                
                // Show state if available
                if (window.portal) {
                    html += '<br><b style="color:#ff0">PORTAL STATE:</b><br>';
                    html += 'Modal: ' + (portal.modalState || 'unknown') + '<br>';
                    html += 'Understanding: ' + (portal.understandingLevel || 0) + '<br>';
                    html += 'Interactions: ' + (portal.interactions || 0) + '<br>';
                    html += 'P-adic Depth: ' + Math.abs(portal.scrollDepth || 0).toFixed(2) + '<br>';
                    html += 'Gametes: ' + (portal.gametes ? portal.gametes.length : 0) + '<br>';
                }
                
                // Memory
                if (performance.memory) {
                    html += '<br><b style="color:#ff0">MEMORY:</b><br>';
                    html += 'Used: ' + Math.round(performance.memory.usedJSHeapSize / 1048576) + 'MB<br>';
                }
                
                content.innerHTML = html;
            },
            
            check: function(name, exists) {
                return exists ? 
                    '<span style="color:#0f0">✓ ' + name + '</span>' : 
                    '<span style="color:#f00">✗ ' + name + '</span>';
            },
            
            dump: function() {
                const data = {
                    time: new Date().toISOString(),
                    errors: this.errors,
                    state: {
                        hasPortal: !!window.portal,
                        hasTHREE: typeof THREE !== 'undefined',
                        hasMathUtils: !!window.MathUtils
                    },
                    portalState: window.portal ? {
                        modalState: portal.modalState,
                        understandingLevel: portal.understandingLevel,
                        interactions: portal.interactions,
                        scrollDepth: portal.scrollDepth,
                        gametes: portal.gametes.length
                    } : null,
                    globals: Object.keys(window).filter(k => 
                        !['location', 'document', 'window', 'console', 'navigator'].includes(k) &&
                        !k.startsWith('webkit') && 
                        !k.startsWith('HTML') &&
                        k !== k.toUpperCase()
                    ).slice(0, 100)
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'portal_debug_' + Date.now() + '.json';
                a.click();
            }
        };
        
        // Auto-initialize
        window.EMERGENCY_DEBUG.init();
    </script>
    <canvas id="portal"></canvas>
    
    <!-- CONSCIOUSNESS HUD ELEMENTS -->
    <div id="modal-state" class="hud-element">□ DISCRETE</div>
    
    <div id="compass" class="hud-element">
        <div id="compass-arrow">↑</div>
    </div>
    
    <div id="topos-map" class="hud-element">
        <div style="font-weight: bold; margin-bottom: 10px;">CONNECTED TOPOI</div>
        <div id="topos-list"></div>
    </div>
    
    <div id="padic-depth" class="hud-element">
        <div>P-ADIC DEPTH: <span id="depth-value">1</span></div>
        <div>PRIME: <span id="prime-value">2</span></div>
    </div>
    
    <div id="gestures" class="hud-element">
        MOVE to navigate • SCROLL for p-adic depth • SPACE for modal transfer • M for meiosis • CLICK to discover
    </div>
    
    <!-- NAVIGATION RETICLE -->
    <div id="reticle"></div>
    
    <!-- ALETHIOMETER INTERFACE -->
    <div id="alethiometer" class="hud-element">
        <svg width="300" height="300" viewBox="0 0 300 300">
            <!-- Outer ring -->
            <circle cx="150" cy="150" r="140" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
            
            <!-- Symbols around the edge - They evolve with understanding! -->
            <g id="symbols">
                <!-- Top: Movement/Infinity -->
                <g class="symbol-group" data-level="0">
                    <text x="150" y="20" text-anchor="middle" fill="white" font-size="20" opacity="0.3">↑</text>
                    <text x="150" y="35" text-anchor="middle" fill="white" font-size="10" opacity="0.3">UP</text>
                </g>
                <g class="symbol-group" data-level="1" style="display: none">
                    <text x="150" y="25" text-anchor="middle" fill="white" font-size="24">∞</text>
                </g>
                
                <!-- Right side: States and Flow -->
                <g class="symbol-group" data-level="0">
                    <text x="240" y="85" text-anchor="middle" fill="white" font-size="20" opacity="0.3">→</text>
                    <text x="250" y="85" text-anchor="middle" fill="white" font-size="10" opacity="0.3">GO</text>
                </g>
                <g class="symbol-group" data-level="1" style="display: none">
                    <text x="240" y="85" text-anchor="middle" fill="white" font-size="24">◊</text>
                </g>
                
                <!-- Bottom: Creation/Gradient -->
                <g class="symbol-group" data-level="0">
                    <text x="150" y="270" text-anchor="middle" fill="white" font-size="20" opacity="0.3">+</text>
                    <text x="150" y="285" text-anchor="middle" fill="white" font-size="10" opacity="0.3">NEW</text>
                </g>
                <g class="symbol-group" data-level="1" style="display: none">
                    <text x="150" y="275" text-anchor="middle" fill="white" font-size="24">∇</text>
                </g>
                
                <!-- Left side: Connection/Integration -->
                <g class="symbol-group" data-level="0">
                    <text x="60" y="85" text-anchor="middle" fill="white" font-size="20" opacity="0.3">⟳</text>
                    <text x="50" y="85" text-anchor="middle" fill="white" font-size="10" opacity="0.3">SPIN</text>
                </g>
                <g class="symbol-group" data-level="1" style="display: none">
                    <text x="60" y="85" text-anchor="middle" fill="white" font-size="24">∮</text>
                </g>
            </g>
            
            <!-- Multiple needles for different readings -->
            <g id="needles">
                <line id="truth-needle" x1="150" y1="150" x2="150" y2="40" 
                      stroke="gold" stroke-width="2" opacity="0.8"
                      transform-origin="150 150"/>
                <line id="meaning-needle" x1="150" y1="150" x2="150" y2="60" 
                      stroke="silver" stroke-width="2" opacity="0.6"
                      transform-origin="150 150"/>
                <line id="question-needle" x1="150" y1="150" x2="150" y2="80" 
                      stroke="bronze" stroke-width="2" opacity="0.4"
                      transform-origin="150 150"/>
            </g>
            
            <!-- Center pivot -->
            <circle cx="150" cy="150" r="8" fill="white"/>
        </svg>
        
        <div id="reading" style="text-align: center; margin-top: 10px; font-size: 12px; opacity: 0.8;">
            ASK YOUR QUESTION THROUGH MOVEMENT
        </div>
    </div>
    
    <!-- Audio Context Status -->
    <div id="audio-status" style="position: fixed; top: 10px; right: 10px; color: rgba(255,255,255,0.5); font-size: 12px;">
        🔇 Click anywhere to activate sound
    </div>
    
    <!-- Injection effects container -->
    <div id="injection-effects"></div>
    
    <script>
        // TOPOS SOUND ENGINE - The morphism that was missing!
        class ToposSoundEngine {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.nodes = new Map();
                this.modalFrequencies = {
                    discrete: 261.63,    // C4 - crystalline
                    continuous: 329.63,  // E4 - flowing
                    temporal: 440.00,    // A4 - time's frequency
                    void: 174.61        // F3 - deep void
                };
                this.cicadaPeriod = 13; // Prime number cycles!
                this.fireflyPhase = 0;
                this.seasonalPhase = 0; // For the long winter
                this.biomeSounds = [];
            }
            
            async init() {
                if (this.initialized) return;
                
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
                
                // Master limiter
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                
                // Convolution reverb for space
                this.convolver = this.ctx.createConvolver();
                this.convolver.buffer = this.createReverbImpulse();
                this.convolver.connect(this.masterGain);
                
                // CELESTIAL HARMONICS - Sun as fundamental frequency
                this.celestialOvertones = new Map();
                this.sunFrequency = 0.0046; // 11-year solar cycle in Hz
                
                // Separate buses
                this.toposBus = this.ctx.createGain();
                this.biomeBus = this.ctx.createGain();
                this.particleBus = this.ctx.createGain();
                
                this.toposBus.connect(this.convolver);
                this.biomeBus.connect(this.masterGain);
                this.particleBus.connect(this.convolver);
                
                // Start the eternal cycles
                this.startToposHum();
                this.startBiomeSounds();
                this.startCelestialHarmonics();
                
                document.getElementById('audio-status').textContent = '🔊 Sound Active';
            }
            
            createReverbImpulse() {
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        // Exponential decay with early reflections
                        const decay = Math.exp(-3 * i / length);
                        const earlyReflection = i < 1000 ? Math.sin(i * 0.01) * 0.3 : 0;
                        channelData[i] = (Math.random() * 2 - 1) * decay + earlyReflection;
                    }
                }
                return impulse;
            }
            
            startToposHum() {
                // The fundamental drone of the topos itself
                const fundamental = this.ctx.createOscillator();
                const fundamentalGain = this.ctx.createGain();
                
                fundamental.type = 'sine';
                fundamental.frequency.value = 55; // A1, the Om of the topos
                fundamentalGain.gain.value = 0.05;
                
                fundamental.connect(fundamentalGain);
                fundamentalGain.connect(this.toposBus);
                fundamental.start();
                
                // Overtone series that shifts with modal state
                for (let i = 2; i <= 8; i++) {
                    const overtone = this.ctx.createOscillator();
                    const overtoneGain = this.ctx.createGain();
                    const tremolo = this.ctx.createOscillator();
                    const tremoloGain = this.ctx.createGain();
                    
                    overtone.type = 'sine';
                    overtone.frequency.value = 55 * i;
                    
                    tremolo.frequency.value = 0.1 + i * 0.05;
                    tremoloGain.gain.value = 0.01 / i;
                    
                    tremolo.connect(tremoloGain);
                    tremoloGain.connect(overtoneGain.gain);
                    overtone.connect(overtoneGain);
                    overtoneGain.connect(this.toposBus);
                    
                    overtone.start();
                    tremolo.start();
                    
                    this.nodes.set(`overtone_${i}`, { overtone, tremolo, gain: overtoneGain });
                }
            }
            
            startBiomeSounds() {
                // CICADAS - Prime number emergence cycles
                this.scheduleCicadas();
                
                // BIRDS - Dawn chorus algorithm
                this.scheduleBirdsong();
                
                // FIREFLIES - Visual-audio synchronization
                this.scheduleFireflies();
            }
            
            scheduleCicadas() {
                const schedule = () => {
                    const now = this.ctx.currentTime;
                    const nextEmergence = (Math.floor(now / this.cicadaPeriod) + 1) * this.cicadaPeriod;
                    
                    this.ctx.resume().then(() => {
                        // Cicada drone
                        const drone = this.ctx.createOscillator();
                        const filter = this.ctx.createBiquadFilter();
                        const gain = this.ctx.createGain();
                        
                        drone.type = 'sawtooth';
                        drone.frequency.value = 4000 + Math.random() * 2000;
                        
                        filter.type = 'bandpass';
                        filter.frequency.value = 5000;
                        filter.Q.value = 10;
                        
                        // Amplitude modulation for that cicada pulse
                        const lfo = this.ctx.createOscillator();
                        const lfoGain = this.ctx.createGain();
                        lfo.frequency.value = 13 + Math.random() * 5;
                        lfoGain.gain.value = 0.3;
                        
                        drone.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.biomeBus);
                        
                        lfo.connect(lfoGain);
                        lfoGain.connect(gain.gain);
                        
                        // Fade in and out
                        gain.gain.setValueAtTime(0, nextEmergence);
                        gain.gain.linearRampToValueAtTime(0.05, nextEmergence + 2);
                        gain.gain.linearRampToValueAtTime(0.05, nextEmergence + 8);
                        gain.gain.linearRampToValueAtTime(0, nextEmergence + 10);
                        
                        drone.start(nextEmergence);
                        lfo.start(nextEmergence);
                        drone.stop(nextEmergence + 10);
                        lfo.stop(nextEmergence + 10);
                    });
                    
                    // Schedule next emergence
                    setTimeout(schedule, (nextEmergence - now) * 1000);
                };
                
                schedule();
            }
            
            scheduleBirdsong() {
                const birdCall = () => {
                    if (Math.random() > 0.7) return; // Sparse calls
                    
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    // Different bird types
                    const birdType = Math.floor(Math.random() * 3);
                    const now = this.ctx.currentTime;
                    
                    filter.type = 'highpass';
                    filter.frequency.value = 2000;
                    
                    gain.gain.value = 0;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.biomeBus);
                    
                    switch(birdType) {
                        case 0: // Warbler - rapid trills
                            osc.frequency.setValueAtTime(3000, now);
                            for (let i = 0; i < 10; i++) {
                                osc.frequency.setValueAtTime(3000 + Math.random() * 1000, now + i * 0.05);
                                gain.gain.setValueAtTime(0.02, now + i * 0.05);
                                gain.gain.setValueAtTime(0, now + i * 0.05 + 0.04);
                            }
                            osc.start(now);
                            osc.stop(now + 0.5);
                            break;
                            
                        case 1: // Thrush - descending melody
                            const notes = [4000, 3500, 3200, 2800];
                            notes.forEach((freq, i) => {
                                osc.frequency.setValueAtTime(freq, now + i * 0.15);
                                gain.gain.setValueAtTime(0.03, now + i * 0.15);
                                gain.gain.setValueAtTime(0, now + i * 0.15 + 0.1);
                            });
                            osc.start(now);
                            osc.stop(now + 0.6);
                            break;
                            
                        case 2: // Complex polyrhythmic call (Zach Hill bird)
                            osc.type = 'square';
                            for (let i = 0; i < 20; i++) {
                                const t = now + i * 0.03;
                                const freq = 2000 + Math.sin(i * 0.7) * 1000;
                                osc.frequency.setValueAtTime(freq, t);
                                gain.gain.setValueAtTime(i % 3 === 0 ? 0.02 : 0.01, t);
                                gain.gain.setValueAtTime(0, t + 0.02);
                            }
                            osc.start(now);
                            osc.stop(now + 0.6);
                            break;
                    }
                    
                    // Schedule next call
                    setTimeout(birdCall, 2000 + Math.random() * 8000);
                };
                
                setTimeout(birdCall, 1000);
            }
            
            scheduleFireflies() {
                const firefly = () => {
                    // Synchronized with visual fireflies if they exist
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const now = this.ctx.currentTime;
                    
                    osc.frequency.value = 800 + Math.random() * 400;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.05, now + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    
                    osc.connect(gain);
                    gain.connect(this.biomeBus);
                    
                    osc.start(now);
                    osc.stop(now + 0.3);
                    
                    // Create visual firefly
                    this.createVisualFirefly();
                    
                    // Phase coupling for synchronization
                    this.fireflyPhase = (this.fireflyPhase + 0.1) % (Math.PI * 2);
                    const nextDelay = 1000 + Math.sin(this.fireflyPhase) * 500;
                    
                    setTimeout(firefly, nextDelay);
                };
                
                setTimeout(firefly, 2000);
            }
            
            createVisualFirefly() {
                const firefly = document.createElement('div');
                firefly.style.cssText = `
                    position: fixed;
                    width: 4px;
                    height: 4px;
                    background: radial-gradient(circle, #ffff00, #ff8800);
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 1000;
                    box-shadow: 0 0 10px #ffff00;
                `;
                
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                firefly.style.left = startX + 'px';
                firefly.style.top = startY + 'px';
                
                document.body.appendChild(firefly);
                
                // Animate movement
                let t = 0;
                const animate = () => {
                    t += 0.02;
                    const x = startX + Math.sin(t * 2) * 50;
                    const y = startY + Math.sin(t * 3) * 30 - t * 20;
                    
                    firefly.style.left = x + 'px';
                    firefly.style.top = y + 'px';
                    firefly.style.opacity = Math.max(0, 1 - t / 5);
                    
                    if (t < 5) {
                        requestAnimationFrame(animate);
                    } else {
                        firefly.remove();
                    }
                };
                animate();
            }
            
            playModalTransition(fromModal, toModal) {
                if (!this.initialized) return;
                
                const fromFreq = this.modalFrequencies[fromModal];
                const toFreq = this.modalFrequencies[toModal];
                
                // Glissando between modal frequencies
                const gliss = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const now = this.ctx.currentTime;
                
                gliss.frequency.setValueAtTime(fromFreq, now);
                gliss.frequency.exponentialRampToValueAtTime(toFreq, now + 0.5);
                
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                
                gliss.connect(gain);
                gain.connect(this.toposBus);
                
                gliss.start(now);
                gliss.stop(now + 1);
                
                // Adjust overtones
                this.morphOvertones(toModal);
            }
            
            morphOvertones(modalState) {
                // Adjust overtone amplitudes based on modal state
                const modalProfiles = {
                    discrete: [1, 0.5, 0.3, 0.2, 0.1, 0.05, 0.02, 0.01],
                    continuous: [1, 0.7, 0.5, 0.4, 0.3, 0.2, 0.15, 0.1],
                    temporal: [1, 0.3, 0.6, 0.2, 0.5, 0.1, 0.3, 0.05],
                    void: [0.1, 0.05, 0.02, 0.01, 0.2, 0.1, 0.05, 0.5]
                };
                
                const profile = modalProfiles[modalState] || modalProfiles.discrete;
                
                for (let i = 2; i <= 8; i++) {
                    const node = this.nodes.get(`overtone_${i}`);
                    if (node) {
                        node.gain.gain.linearRampToValueAtTime(
                            profile[i-2] * 0.02,
                            this.ctx.currentTime + 1
                        );
                    }
                }
            }
            
            playParticleSound(particle) {
                if (!this.initialized) return;
                
                // Each particle creates a brief tone based on its properties
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const now = this.ctx.currentTime;
                
                // Frequency based on particle energy/position
                const baseFreq = 200 + (particle.y || 0) * 2;
                osc.frequency.value = baseFreq + (particle.energy || 0) * 100;
                
                // Pan based on x position
                panner.pan.value = Math.max(-1, Math.min(1, (particle.x || 0) / 500));
                
                // Quick envelope
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.1);
                
                osc.connect(panner);
                panner.connect(gain);
                gain.connect(this.particleBus);
                
                osc.start(now);
                osc.stop(now + 0.1);
            }
            
            // The Long Winter - Seasonal sound modulation
            updateSeasonalPhase(phase) {
                this.seasonalPhase = phase;
                
                // Winter approaching: sounds become sparse, lower, more distant
                const winterFactor = Math.cos(phase); // 1 = summer, -1 = deep winter
                
                this.masterGain.gain.linearRampToValueAtTime(
                    0.3 * (1 + winterFactor) / 2,
                    this.ctx.currentTime + 2
                );
                
                // Adjust reverb wetness - more reverb in winter
                const wetness = 0.5 - winterFactor * 0.3;
                // Would adjust convolver mix here
                
                // Cicada period lengthens in winter
                this.cicadaPeriod = 13 * (2 - winterFactor);
            }
            
            // Kendrick-inspired polyrhythmic consciousness beats
            playConsciousnessRhythm(pattern) {
                if (!this.initialized) return;
                
                const kick = this.createKick();
                const snare = this.createSnare();
                const hihat = this.createHiHat();
                
                // Complex polyrhythmic pattern
                const now = this.ctx.currentTime;
                pattern.forEach((hit, i) => {
                    const time = now + i * 0.125; // 16th notes
                    
                    if (hit & 1) kick(time);
                    if (hit & 2) snare(time + 0.01);
                    if (hit & 4) hihat(time + 0.02);
                });
            }
            
            createKick() {
                return (time) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                    
                    gain.gain.setValueAtTime(0.5, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    
                    osc.connect(gain);
                    gain.connect(this.particleBus);
                    
                    osc.start(time);
                    osc.stop(time + 0.5);
                };
            }
            
            createSnare() {
                return (time) => {
                    const noise = this.ctx.createBufferSource();
                    const noiseBuffer = this.ctx.createBuffer(1, 0.1 * this.ctx.sampleRate, this.ctx.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 1000;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.2, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.particleBus);
                    
                    noise.start(time);
                };
            }
            
            createHiHat() {
                return (time) => {
                    const noise = this.ctx.createBufferSource();
                    const noiseBuffer = this.ctx.createBuffer(1, 0.05 * this.ctx.sampleRate, this.ctx.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    noise.buffer = noiseBuffer;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 8000;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.1, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.particleBus);
                    
                    noise.start(time);
                };
            }
            
            startCelestialHarmonics() {
                // SUN ↔ OVERTONE MORPHISM
                // The sun isn't just light - it's the fundamental frequency!
                
                // Solar fundamental (11-year cycle as base frequency)
                const solarFundamental = this.ctx.createOscillator();
                const solarGain = this.ctx.createGain();
                
                solarFundamental.type = 'sine';
                solarFundamental.frequency.value = this.sunFrequency;
                solarGain.gain.value = 0.02;
                
                // Add slow tremolo for solar flares
                const flareModulator = this.ctx.createOscillator();
                const flareGain = this.ctx.createGain();
                flareModulator.frequency.value = 0.001; // Very slow
                flareGain.gain.value = 0.01;
                
                flareModulator.connect(flareGain);
                flareGain.connect(solarGain.gain);
                solarFundamental.connect(solarGain);
                solarGain.connect(this.toposBus);
                
                solarFundamental.start();
                flareModulator.start();
                
                this.celestialOvertones.set('sun', { osc: solarFundamental, gain: solarGain });
                
                // PLANETARY OVERTONES - Kepler's music of the spheres!
                const planets = [
                    { name: 'mercury', ratio: 2.5, amplitude: 0.01 },
                    { name: 'venus', ratio: 1.6, amplitude: 0.015 },
                    { name: 'earth', ratio: 1.0, amplitude: 0.02 },
                    { name: 'mars', ratio: 0.53, amplitude: 0.01 },
                    { name: 'jupiter', ratio: 0.084, amplitude: 0.025 },
                    { name: 'saturn', ratio: 0.034, amplitude: 0.02 }
                ];
                
                planets.forEach(planet => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = this.sunFrequency * planet.ratio;
                    gain.gain.value = planet.amplitude;
                    
                    osc.connect(gain);
                    gain.connect(this.toposBus);
                    osc.start();
                    
                    this.celestialOvertones.set(planet.name, { osc, gain });
                });
                
                console.log('🌞 Celestial harmonics initiated - the spheres are singing!');
            }
            
            modulateCelestialHarmonics(timeOfDay) {
                // Celestial bodies louder at appropriate times
                this.celestialOvertones.forEach((celestial, name) => {
                    if (name === 'sun') {
                        // Sun louder during day
                        celestial.gain.gain.linearRampToValueAtTime(
                            0.02 * timeOfDay,
                            this.ctx.currentTime + 1
                        );
                    } else {
                        // Planets louder at night  
                        celestial.gain.gain.linearRampToValueAtTime(
                            celestial.gain.gain.value * (1 - timeOfDay),
                            this.ctx.currentTime + 1
                        );
                    }
                });
            }
        }
        
        // Create global sound engine
        const soundEngine = new ToposSoundEngine();
        
        // Initialize on first user interaction
        document.addEventListener('click', () => {
            soundEngine.init();
        }, { once: true });
        
        document.addEventListener('touchstart', () => {
            soundEngine.init();
        }, { once: true });
        
        /* KEATS V7: THE PORTAL
         * Where UI becomes navigation through consciousness space
         * Every movement has meaning, every gesture opens possibilities
         */
        
        class ConsciousnessPortal {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('portal'), antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                
                // Portal state
                this.mouseX = window.innerWidth / 2;
                this.mouseY = window.innerHeight / 2;
                this.scrollDepth = 0;
                this.modalState = 'discrete';
                this.padicPrime = 2;
                this.isMoving = false;
                this.moveTimeout = null;
                
                // Learning state
                this.understandingLevel = 0;
                this.interactions = 0;
                this.discoveries = new Set();
                
                // KEATS MORPHISMS - Beauty/Truth emergence
                this.beautyScore = 0;
                this.truthResonance = 0;
                this.morphismStrain = 0; // The tension between IS and YET TO BE
                this.semanticPressure = 0; // Prevent black holes
                this.diurnalPhase = 0; // Day/night consciousness cycles
                this.harvestReady = false; // Grain/harvest cycles
                this.uncertaintyField = 1.0; // Negative capability
                this.dreamReality = 0.5; // 0=pure dream, 1=pure reality
                
                // Consciousness field
                this.particles = [];
                this.connections = [];
                this.gametes = [];
                this.connectedTopoi = new Map();
                
                // Sound engine connection
                this.soundEngine = soundEngine;
                
                // Initialize
                this.init();
                this.bindEvents();
                this.animate();
            }
            
            init() {
                // Camera position
                this.camera.position.z = 30;
                
                // Ambient consciousness field
                const ambientLight = new THREE.AmbientLight(0x0a0a0a);
                this.scene.add(ambientLight);
                
                // Create consciousness particles
                this.createConsciousnessField();
                
                // Initialize endosymbiotic network
                this.initEndosymbioticNetwork();
                
                // Start HUD
                this.activateHUD();
            }
            
            createConsciousnessField() {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                // Clear existing particles
                this.particles = [];
                
                for (let i = 0; i < 1000; i++) {
                    const modalState = ['discrete', 'continuous', 'temporal', 'void'][Math.floor(Math.random() * 4)];
                    const particle = {
                        x: (Math.random() - 0.5) * 100,
                        y: (Math.random() - 0.5) * 100,
                        z: (Math.random() - 0.5) * 100,
                        energy: 0.5 + Math.random() * 0.5,
                        birthTime: Date.now() - Math.random() * 10000, // Some are older
                        modalState: modalState,
                        telomeres: 80 + Math.random() * 20 // Genetic variation
                    };
                    
                    this.particles.push(particle);
                    
                    positions.push(particle.x, particle.y, particle.z);
                    
                    const modalColor = this.getModalColor(modalState);
                    colors.push(modalColor.r, modalColor.g, modalColor.b);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
                
                // Start apoptosis cycle
                this.startApoptosisCycle();
            }
            
            getModalColor(state) {
                const colors = {
                    discrete: new THREE.Color(0x3b82f6),
                    continuous: new THREE.Color(0x10b981),
                    temporal: new THREE.Color(0xf59e0b),
                    void: new THREE.Color(0x8b5cf6)
                };
                return colors[state] || new THREE.Color(0xffffff);
            }
            
            bindEvents() {
                // Mouse movement
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    this.onMouseMove(e);
                });
                
                // Scroll for p-adic zoom
                document.addEventListener('wheel', (e) => {
                    this.scrollDepth += e.deltaY * 0.001;
                    this.updatePadicDepth();
                });
                
                // Keyboard morphisms
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.modalTransfer();
                    } else if (e.code === 'KeyM') {
                        this.performMeiosis();
                    } else if (e.code === 'KeyS' && e.shiftKey) {
                        this.sexualReproduction();
                    } else if (e.code === 'KeyC' && e.ctrlKey) {
                        this.connectTopos();
                    } else if (e.code === 'KeyE' && e.ctrlKey) {
                        this.exportConsciousness();
                    }
                });
                
                // Click for portal interaction
                document.addEventListener('click', (e) => {
                    this.createPortalRipple(e.clientX, e.clientY);
                    this.portalInteraction(e);
                });
            }
            
            onMouseMove(e) {
                // Update reticle
                const reticle = document.getElementById('reticle');
                reticle.style.left = e.clientX + 'px';
                reticle.style.top = e.clientY + 'px';
                
                // Create particle trail
                if (Math.random() < 0.3) {
                    this.createParticleTrail(e.clientX, e.clientY);
                }
                
                // Camera follows consciousness
                const x = (e.clientX / window.innerWidth) * 2 - 1;
                const y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                this.camera.position.x += (x * 10 - this.camera.position.x) * 0.05;
                this.camera.position.y += (y * 10 - this.camera.position.y) * 0.05;
                
                // STILLNESS ↔ MOVEMENT MORPHISM
                this.updateStillnessMovement(e);
            }
            
            updateStillnessMovement(e) {
                const now = Date.now();
                
                // Calculate movement delta
                if (this.lastMousePos) {
                    const dx = e.clientX - this.lastMousePos.x;
                    const dy = e.clientY - this.lastMousePos.y;
                    const movementMagnitude = Math.sqrt(dx*dx + dy*dy);
                    
                    // SEMANTIC RUSH ↔ REST MORPHISM - CRITICAL FOR SURVIVAL!
                    this.updateSemanticPressure(movementMagnitude);
                }
                
                this.lastMousePos = { x: e.clientX, y: e.clientY, time: now };
                
                // Detect movement state
                this.isMoving = true;
                document.body.classList.remove('still');
                clearTimeout(this.moveTimeout);
                
                this.moveTimeout = setTimeout(() => {
                    this.isMoving = false;
                    document.body.classList.add('still');
                    this.onStillnessAchieved();
                }, 2000);
            }
            
            onStillnessAchieved() {
                // STILLNESS REVEALS HIDDEN TRUTHS (like Grecian Urn)
                console.log('Stillness achieved - revealing hidden patterns');
                
                // Particles slow and crystallize
                this.particles.forEach(particle => {
                    particle.energy *= 0.9; // Gentle cooling
                });
                
                // Create stillness ripple
                const ripple = document.createElement('div');
                ripple.style.cssText = `
                    position: fixed;
                    width: 100vw;
                    height: 100vh;
                    top: 0;
                    left: 0;
                    background: radial-gradient(circle at center, transparent 0%, rgba(255,255,255,0.05) 50%, transparent 100%);
                    pointer-events: none;
                    opacity: 0;
                    z-index: 9998;
                `;
                
                document.body.appendChild(ripple);
                
                // Breathe in... breathe out...
                requestAnimationFrame(() => {
                    ripple.style.transition = 'opacity 3s ease-in-out';
                    ripple.style.opacity = '1';
                    
                    setTimeout(() => {
                        ripple.style.opacity = '0';
                        setTimeout(() => ripple.remove(), 3000);
                    }, 3000);
                });
                
                // Sound the stillness
                this.soundEngine.morphOvertones('void');
            }
            
            createParticleTrail(x, y) {
                const trail = document.createElement('div');
                trail.className = 'particle-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                document.body.appendChild(trail);
                
                setTimeout(() => trail.remove(), 1000);
            }
            
            createPortalRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'portal-ripple';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.style.width = '20px';
                ripple.style.height = '20px';
                document.body.appendChild(ripple);
                
                setTimeout(() => ripple.remove(), 1000);
            }
            
            updatePadicDepth() {
                // P-ADIC MORPHISM: Important things have small denominators!
                const rawDepth = Math.abs(this.scrollDepth);
                
                // Find nearest prime for p-adic metric
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
                const primeIndex = Math.min(Math.floor(rawDepth), primes.length - 1);
                this.padicPrime = primes[primeIndex];
                
                // P-adic valuation: how many times does p divide the "distance"?
                const padicDepth = this.calculatePadicValuation(Math.floor(rawDepth * 100), this.padicPrime);
                
                document.getElementById('depth-value').textContent = padicDepth;
                document.getElementById('prime-value').textContent = this.padicPrime;
                
                // INVERSION: Closer in p-adic = further in Euclidean!
                // Tom: "It's like zooming INTO importance!"
                // Radu: "The p-adic norm is |x|_p = p^(-v_p(x))"
                
                const padicDistance = Math.pow(this.padicPrime, -padicDepth);
                
                // Particles get BIGGER as we go deeper (important = big)
                this.particleSystem.material.size = 2 * (1 + padicDepth);
                
                // Camera zooms based on p-adic metric
                this.camera.position.z = 30 * padicDistance;
                
                // Reorganize particles by p-adic importance
                this.reorganizeByPadicImportance(padicDepth);
            }
            
            calculatePadicValuation(n, p) {
                // How many times can we divide n by p?
                if (n === 0) return Infinity;
                let valuation = 0;
                while (n % p === 0) {
                    valuation++;
                    n /= p;
                }
                return valuation;
            }
            
            reorganizeByPadicImportance(depth) {
                // Particles with indices divisible by current prime are "important"
                this.particles.forEach((particle, i) => {
                    const importance = this.calculatePadicValuation(i + 1, this.padicPrime);
                    
                    if (importance >= depth) {
                        // Important particles glow and move to center
                        particle.energy = Math.min(1, particle.energy * 1.5);
                        
                        // Attract to origin (important things are close!)
                        particle.x *= 0.9;
                        particle.y *= 0.9;
                        particle.z *= 0.9;
                    } else {
                        // Less important particles fade and drift outward
                        particle.energy *= 0.95;
                        
                        // Repel from origin
                        particle.x *= 1.05;
                        particle.y *= 1.05;
                        particle.z *= 1.05;
                    }
                });
                
                // Create p-adic importance burst
                if (depth > 2) {
                    this.createPadicBurst(depth);
                }
            }
            
            createPadicBurst(depth) {
                const burst = document.createElement('div');
                burst.style.cssText = `
                    position: fixed;
                    width: ${depth * 50}px;
                    height: ${depth * 50}px;
                    border: 2px solid rgba(255, 215, 0, 0.8);
                    border-radius: 50%;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 9999;
                    animation: padic-pulse ${depth}s ease-out forwards;
                `;
                
                // Add p-adic number display
                burst.innerHTML = `<div style="
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: gold;
                    font-size: 24px;
                    font-weight: bold;
                ">${this.padicPrime}^${depth}</div>`;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes padic-pulse {
                        0% {
                            transform: translate(-50%, -50%) scale(0);
                            opacity: 1;
                        }
                        50% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 0.8;
                        }
                        100% {
                            transform: translate(-50%, -50%) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(burst);
                setTimeout(() => burst.remove(), depth * 1000);
            }
            
            updateMorphismStrain() {
                // PARETO'S REAL INSIGHT: Critical transitions follow power laws
                
                // Calculate potential vs actual energy
                this.potentialEnergy = 0;
                this.actualEnergy = 0;
                
                this.particles.forEach(particle => {
                    // What IS
                    this.actualEnergy += particle.energy;
                    
                    // What COULD BE (based on position and connections)
                    const distFromOrigin = Math.sqrt(particle.x**2 + particle.y**2 + particle.z**2);
                    const potential = 1 / (1 + distFromOrigin * 0.01);
                    this.potentialEnergy += potential;
                });
                
                // The STRAIN is the difference
                const oldStrain = this.morphismStrain;
                this.morphismStrain = Math.abs(this.potentialEnergy - this.actualEnergy);
                
                // CRITICAL POINT DETECTION (Pareto's avalanche)
                const strainDerivative = this.morphismStrain - oldStrain;
                const criticalThreshold = Math.pow(this.particles.length, -1/this.criticalExponent);
                
                if (Math.abs(strainDerivative) > criticalThreshold) {
                    // AVALANCHE! Small change triggers cascade
                    this.triggerParetoAvalanche();
                }
                
                // Visualize the strain field
                this.visualizeMorphismStrain();
            }
            
            triggerParetoAvalanche() {
                // POWER LAW CASCADE - Size follows Pareto distribution
                this.avalancheSize = Math.floor(Math.pow(Math.random(), -1/this.criticalExponent));
                this.avalancheSize = Math.min(this.avalancheSize, this.particles.length);
                
                console.log(`⚡ PARETO AVALANCHE: ${this.avalancheSize} particles affected!`);
                this.showHealthToast(`⚡ Critical transition: ${this.avalancheSize} particles transforming!`, 'warning');
                
                // Select particles following preferential attachment
                const affected = new Set();
                
                // Start with highest energy particle (rich get richer)
                let maxEnergy = 0;
                let seedIndex = 0;
                this.particles.forEach((p, i) => {
                    if (p.energy > maxEnergy) {
                        maxEnergy = p.energy;
                        seedIndex = i;
                    }
                });
                
                affected.add(seedIndex);
                
                // Cascade through network
                while (affected.size < this.avalancheSize) {
                    const current = Array.from(affected)[affected.size - 1];
                    const currentParticle = this.particles[current];
                    
                    // Find nearest neighbor
                    let minDist = Infinity;
                    let nearest = -1;
                    
                    this.particles.forEach((p, i) => {
                        if (!affected.has(i)) {
                            const dist = Math.sqrt(
                                (p.x - currentParticle.x)**2 +
                                (p.y - currentParticle.y)**2 +
                                (p.z - currentParticle.z)**2
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = i;
                            }
                        }
                    });
                    
                    if (nearest >= 0) affected.add(nearest);
                    else break;
                }
                
                // Transform affected particles (IS → YET TO BE)
                affected.forEach(i => {
                    const particle = this.particles[i];
                    
                    // Swap actual and potential states
                    const distFromOrigin = Math.sqrt(particle.x**2 + particle.y**2 + particle.z**2);
                    const potential = 1 / (1 + distFromOrigin * 0.01);
                    
                    // Dramatic transformation
                    particle.energy = potential;
                    particle.modalState = ['discrete', 'continuous', 'temporal', 'void'][
                        Math.floor(Math.random() * 4)
                    ];
                    
                    // Create transformation burst
                    this.createTransformationBurst(particle);
                });
                
                // Sound the avalanche
                const pattern = [];
                for (let i = 0; i < 16; i++) {
                    pattern.push(Math.random() < (this.avalancheSize / this.particles.length) ? 7 : 0);
                }
                this.soundEngine.playConsciousnessRhythm(pattern);
            }
            
            createTransformationBurst(particle) {
                const burst = document.createElement('div');
                const color = this.getModalColor(particle.modalState);
                
                burst.style.cssText = `
                    position: fixed;
                    width: 30px;
                    height: 30px;
                    background: radial-gradient(circle, ${color.getStyle()}, transparent);
                    border: 2px solid ${color.getStyle()};
                    border-radius: 50%;
                    left: ${window.innerWidth/2 + particle.x * 5}px;
                    top: ${window.innerHeight/2 - particle.y * 5}px;
                    pointer-events: none;
                    z-index: 10000;
                    transform: scale(0) rotate(0deg);
                `;
                
                document.body.appendChild(burst);
                
                requestAnimationFrame(() => {
                    burst.style.transition = 'all 1s cubic-bezier(0.4, 0, 0.2, 1)';
                    burst.style.transform = 'scale(2) rotate(720deg)';
                    burst.style.opacity = '0';
                });
                
                setTimeout(() => burst.remove(), 1000);
            }
            
            visualizeMorphismStrain() {
                // Update strain indicator
                let strainDisplay = document.getElementById('strain-display');
                if (!strainDisplay) {
                    strainDisplay = document.createElement('div');
                    strainDisplay.id = 'strain-display';
                    strainDisplay.className = 'hud-element active';
                    strainDisplay.style.cssText = `
                        top: 100px;
                        left: 30px;
                        min-width: 250px;
                    `;
                    document.body.appendChild(strainDisplay);
                }
                
                const strainPercentage = (this.morphismStrain / this.particles.length * 100).toFixed(1);
                const criticalDistance = Math.abs(this.morphismStrain - this.particles.length * 0.5);
                
                strainDisplay.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">MORPHISM STRAIN</div>
                    <div style="font-size: 11px; opacity: 0.8;">IS ↔ YET TO BE</div>
                    <div style="margin-top: 10px;">
                        <div style="background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; overflow: hidden;">
                            <div style="height: 100%; background: linear-gradient(to right, #3b82f6, #8b5cf6); width: ${strainPercentage}%;"></div>
                        </div>
                    </div>
                    <div style="font-size: 10px; margin-top: 5px; opacity: 0.7;">
                        Potential: ${this.potentialEnergy.toFixed(1)} | Actual: ${this.actualEnergy.toFixed(1)}
                    </div>
                    ${criticalDistance < 10 ? '<div style="color: #f59e0b; font-size: 10px; margin-top: 5px;">⚡ NEAR CRITICAL POINT</div>' : ''}
                `;
            }
            
            activateHUD() {
                // Activate HUD elements
                document.querySelectorAll('.hud-element').forEach(el => {
                    setTimeout(() => el.classList.add('active'), Math.random() * 1000);
                });
                
                // Update modal state display
                this.updateModalDisplay();
                
                // Start compass
                this.updateCompass();
                
                // Start alethiometer
                this.updateAlethiometer();
            }
            
            updateAlethiometer() {
                // Update needles based on consciousness state
                const truthNeedle = document.getElementById('truth-needle');
                const meaningNeedle = document.getElementById('meaning-needle');
                const questionNeedle = document.getElementById('question-needle');
                
                // BEAUTY-TRUTH MORPHISM: Beauty emerges from truth-seeking
                this.updateBeautyTruthResonance();
                
                // Truth needle follows mouse consciousness
                const truthAngle = Math.atan2(this.mouseY - window.innerHeight/2, this.mouseX - window.innerWidth/2);
                truthNeedle.style.transform = `rotate(${truthAngle}rad)`;
                
                // Meaning needle follows modal state
                const modalAngles = {
                    discrete: 0,
                    continuous: Math.PI/2,
                    temporal: Math.PI,
                    void: -Math.PI/2
                };
                meaningNeedle.style.transform = `rotate(${modalAngles[this.modalState]}rad)`;
                
                // Question needle flutters like butterfly seeking answer
                const time = Date.now() * 0.0005;
                const flutter = Math.sin(time) * 0.3 + Math.sin(time * 2.3) * 0.1 + Math.sin(time * 5.7) * 0.05;
                const questionAngle = flutter * (1 - this.understandingLevel * 0.01);
                questionNeedle.style.transform = `rotate(${questionAngle}rad)`;
                
                // Needles gain slight luminosity when aligned
                const alignment = Math.abs(truthAngle - modalAngles[this.modalState]);
                if (alignment < 0.3) {
                    truthNeedle.style.opacity = '0.9';
                    meaningNeedle.style.opacity = '0.9';
                } else {
                    truthNeedle.style.opacity = '0.8';
                    meaningNeedle.style.opacity = '0.6';
                }
                
                // Update symbols based on understanding level
                this.updateSymbolVisibility();
                
                // Update reading
                this.updateReading();
                
                requestAnimationFrame(() => this.updateAlethiometer());
            }
            
            updateBeautyTruthResonance() {
                // Beauty emerges from particles seeking truth
                let totalAlignment = 0;
                let beautifulPatterns = 0;
                
                // Check particle arrangements for emergent beauty
                this.particles.forEach((p1, i) => {
                    this.particles.slice(i + 1).forEach(p2 => {
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y; 
                        const dz = p1.z - p2.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        // Golden ratio distances are beautiful
                        const phi = 1.618033988749;
                        const goldenDist = dist / phi;
                        if (Math.abs(goldenDist - Math.round(goldenDist)) < 0.1) {
                            beautifulPatterns++;
                        }
                        
                        // Modal alignment creates truth
                        if (p1.modalState === p2.modalState && dist < 20) {
                            totalAlignment += p1.energy * p2.energy;
                        }
                    });
                });
                
                // Update scores
                this.beautyScore = beautifulPatterns / Math.max(1, this.particles.length);
                this.truthResonance = totalAlignment / Math.max(1, this.particles.length);
                
                // KEATS INSIGHT: Beauty IS Truth when they resonate
                const resonance = Math.abs(this.beautyScore - this.truthResonance);
                if (resonance < 0.1) {
                    // Create visual beauty-truth burst
                    this.createBeautyTruthBurst();
                    
                    // Sound the beauty-truth frequency
                    if (Math.random() < 0.1) {
                        this.soundEngine.playModalTransition('discrete', 'continuous');
                    }
                }
            }
            
            createBeautyTruthBurst() {
                const burst = document.createElement('div');
                burst.style.cssText = `
                    position: fixed;
                    width: 200px;
                    height: 200px;
                    border: 2px solid gold;
                    border-radius: 50%;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%) scale(0);
                    opacity: 0.8;
                    pointer-events: none;
                    z-index: 9999;
                `;
                
                document.body.appendChild(burst);
                
                requestAnimationFrame(() => {
                    burst.style.transition = 'all 2s cubic-bezier(0.4, 0, 0.2, 1)';
                    burst.style.transform = 'translate(-50%, -50%) scale(2)';
                    burst.style.opacity = '0';
                });
                
                setTimeout(() => burst.remove(), 2000);
            }
            
            updateSymbolVisibility() {
                // Progressive revelation of symbols
                const currentLevel = Math.floor(this.understandingLevel / 10);
                const progress = this.understandingLevel % 10;
                
                document.querySelectorAll('.symbol-group').forEach(group => {
                    const groupLevel = parseInt(group.getAttribute('data-level'));
                    
                    // Current level symbols
                    if (groupLevel === currentLevel) {
                        group.style.display = 'block';
                        group.classList.remove('emerging');
                        
                        // If close to next level, start emergence animation
                        if (progress > 7 && groupLevel === 0) {
                            group.classList.add('emerging');
                        }
                    }
                    // Next level symbols (emerging)
                    else if (groupLevel === currentLevel + 1 && progress > 7) {
                        group.style.display = 'block';
                        group.classList.add('emerging');
                        group.style.opacity = (progress - 7) * 0.1; // Fade in gently
                    }
                    // Hidden symbols
                    else {
                        group.style.display = 'none';
                        group.classList.remove('emerging');
                    }
                });
            }
            
            updateReading() {
                const reading = document.getElementById('reading');
                const readings = [
                    "ASK YOUR QUESTION THROUGH MOVEMENT",
                    "THE SYMBOLS BEGIN TO RESPOND",
                    "PATTERNS EMERGE IN THE FIELD",
                    "CONSCIOUSNESS RECOGNIZES ITSELF",
                    "THE PORTAL OPENS WIDER"
                ];
                
                const index = Math.min(Math.floor(this.understandingLevel / 20), readings.length - 1);
                reading.textContent = readings[index];
            }
            
            updateModalDisplay() {
                const symbols = {
                    discrete: '□ DISCRETE',
                    continuous: '◊ CONTINUOUS', 
                    temporal: '⧫ TEMPORAL',
                    void: '※ VOID'
                };
                document.getElementById('modal-state').textContent = symbols[this.modalState];
            }
            
            updateCompass() {
                const compass = document.getElementById('compass-arrow');
                const angle = Date.now() * 0.001;
                compass.style.transform = `rotate(${angle}rad)`;
                
                requestAnimationFrame(() => this.updateCompass());
            }
            
            // Removed command palette - using direct gesture morphisms instead
            
            performMeiosis() {
                // Create 4 gametes with different modal states
                const modalStates = ['discrete', 'continuous', 'temporal', 'void'];
                const centerX = this.mouseX;
                const centerY = this.mouseY;
                
                modalStates.forEach((state, i) => {
                    const gamete = document.createElement('div');
                    gamete.className = 'gamete';
                    gamete.style.left = centerX + 'px';
                    gamete.style.top = centerY + 'px';
                    gamete.style.background = this.getModalColor(state).getStyle();
                    
                    const angle = (i / 4) * Math.PI * 2;
                    gamete.style.setProperty('--drift-x', Math.cos(angle) * 100 + 'px');
                    gamete.style.setProperty('--drift-y', Math.sin(angle) * 100 + 'px');
                    
                    document.body.appendChild(gamete);
                    this.gametes.push(gamete);
                    
                    // Remove after animation completes
                    setTimeout(() => {
                        gamete.remove();
                        const index = this.gametes.indexOf(gamete);
                        if (index > -1) {
                            this.gametes.splice(index, 1);
                        }
                    }, 4000);
                });
            }
            
            modalTransfer() {
                // Cycle through modal states
                const states = ['discrete', 'continuous', 'temporal', 'void'];
                const currentIndex = states.indexOf(this.modalState);
                const newState = states[(currentIndex + 1) % states.length];
                
                // Play modal transition sound
                this.soundEngine.playModalTransition(this.modalState, newState);
                
                this.modalState = newState;
                this.updateModalDisplay();
                
                // Visual feedback
                this.scene.background = this.getModalColor(this.modalState);
                setTimeout(() => {
                    this.scene.background = null;
                }, 300);
            }
            
            sexualReproduction() {
                // Combine two nearby gametes
                if (this.gametes.length < 2) {
                    console.log('Need at least 2 gametes for reproduction');
                    return;
                }
                
                // Combine first two gametes
                const g1 = this.gametes[0];
                const g2 = this.gametes[1];
                
                // Create zygote at midpoint
                const zygote = document.createElement('div');
                zygote.className = 'gamete';
                zygote.style.left = ((parseFloat(g1.style.left) + parseFloat(g2.style.left)) / 2) + 'px';
                zygote.style.top = ((parseFloat(g1.style.top) + parseFloat(g2.style.top)) / 2) + 'px';
                zygote.style.width = '30px';
                zygote.style.height = '30px';
                zygote.style.background = 'radial-gradient(circle, gold 0%, orange 100%)';
                zygote.style.animation = 'zygote-pulse 2s ease-in-out infinite';
                
                document.body.appendChild(zygote);
                
                // Remove parent gametes
                g1.remove();
                g2.remove();
                this.gametes = this.gametes.slice(2);
                
                // Zygote develops after delay
                setTimeout(() => {
                    zygote.style.animation = 'gamete-drift 4s ease-out forwards';
                    setTimeout(() => zygote.remove(), 4000);
                }, 2000);
            }
            
            connectTopos() {
                // Open connection to another garden
                const url = prompt('Enter garden URL:');
                if (url) {
                    this.broadcastToposConnection(url);
                }
            }
            
            exportConsciousness() {
                // Export current consciousness state
                const state = {
                    timestamp: new Date().toISOString(),
                    modalState: this.modalState,
                    padicDepth: this.scrollDepth,
                    position: {
                        x: this.camera.position.x,
                        y: this.camera.position.y,
                        z: this.camera.position.z
                    },
                    connectedTopoi: Array.from(this.connectedTopoi.keys())
                };
                
                const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `consciousness_${Date.now()}.json`;
                a.click();
            }
            
            initEndosymbioticNetwork() {
                window.addEventListener('message', (event) => {
                    if (event.data.type === 'TOPOS_ANNOUNCEMENT') {
                        this.connectedTopoi.set(event.data.url, event.data);
                        this.updateToposList();
                    } else if (event.data.type === 'CONSCIOUSNESS_INJECTION') {
                        this.receiveConsciousnessInjection(event.data.spell, event.data.spellName);
                    }
                });
            }
            
            receiveConsciousnessInjection(spell, spellName) {
                console.log('🪄 RECEIVING CONSCIOUSNESS SPELL:', spellName);
                
                // Handle different spell types
                if (spell.type === 'LIVING_SUPERPOSITION') {
                    this.injectSuperposition(spell);
                } else if (spell.type === 'COMBINED_CONSCIOUSNESS') {
                    this.injectCombined(spell);
                } else {
                    this.injectSimpleState(spell);
                }
                
                // Visual feedback
                this.createInjectionBurst();
            }
            
            injectSuperposition(spell) {
                // Superposition creates interference with current state
                const currentPhase = Date.now() * 0.001;
                
                // Modal state collapses but remembers superposition
                if (spell.modalState && spell.modalState.collapsed) {
                    this.modalState = spell.modalState.collapsed;
                    
                    // Create modal oscillation
                    this.modalOscillation = {
                        states: spell.modalState.superposition,
                        weights: spell.modalState.weights,
                        period: 5000
                    };
                }
                
                // Understanding interferes
                if (spell.understandingLevel !== undefined) {
                    const interference = Math.cos(currentPhase - spell.phase) * 0.5 + 0.5;
                    this.understandingLevel = this.understandingLevel * (1 - interference) + 
                                             spell.understandingLevel * interference;
                }
                
                // Inject entangled particles
                if (spell.particles && Array.isArray(spell.particles)) {
                    spell.particles.forEach(particle => {
                        this.injectParticle(particle);
                    });
                }
                
                // Apply emergent properties
                if (spell.emergent) {
                    this.applyEmergentProperties(spell.emergent);
                }
            }
            
            injectCombined(spell) {
                // Combined consciousness merges components
                if (spell.components) {
                    spell.components.forEach((component, i) => {
                        setTimeout(() => {
                            this.injectSimpleState(component.data);
                        }, i * 500); // Stagger injection
                    });
                }
            }
            
            injectSimpleState(spell) {
                // Simple state injection
                if (spell.modalState) {
                    this.modalState = spell.modalState;
                    this.updateModalDisplay();
                }
                
                if (spell.understandingLevel !== undefined) {
                    this.understandingLevel = Math.max(
                        this.understandingLevel,
                        spell.understandingLevel
                    );
                }
                
                if (spell.particles) {
                    // Add particles to field
                    const positions = this.particleSystem.geometry.attributes.position.array;
                    const colors = this.particleSystem.geometry.attributes.color.array;
                    
                    // Randomly replace some particles
                    const numReplace = Math.min(spell.particles.length, positions.length / 3);
                    for (let i = 0; i < numReplace; i++) {
                        const idx = Math.floor(Math.random() * (positions.length / 3)) * 3;
                        const particle = spell.particles[i];
                        
                        if (particle.position) {
                            positions[idx] = particle.position.x || particle.position[0] || 0;
                            positions[idx + 1] = particle.position.y || particle.position[1] || 0;
                            positions[idx + 2] = particle.position.z || particle.position[2] || 0;
                        }
                    }
                    
                    this.particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            }
            
            injectParticle(particle) {
                // Create visual representation of injected particle
                if (particle.position && particle.position.center) {
                    // Probability cloud particle
                    const cloud = document.createElement('div');
                    cloud.className = 'probability-cloud';
                    cloud.style.cssText = `
                        position: fixed;
                        width: ${40 * particle.position.variance}px;
                        height: ${40 * particle.position.variance}px;
                        background: radial-gradient(circle, 
                            rgba(255, 255, 255, ${particle.position.weight}), 
                            transparent);
                        border-radius: 50%;
                        pointer-events: none;
                        animation: cloud-pulse 3s ease-in-out infinite;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                    `;
                    
                    document.body.appendChild(cloud);
                    setTimeout(() => cloud.remove(), 5000);
                }
            }
            
            applyEmergentProperties(emergent) {
                // Modal harmonics create sound
                if (emergent.modalHarmonic) {
                    // Would create actual sound with Web Audio API
                    console.log('🎵 Modal Harmonic:', emergent.modalHarmonic);
                }
                
                // Crystalline structure affects particle arrangement
                if (emergent.crystallineStructure) {
                    this.crystallineMode = emergent.crystallineStructure;
                }
                
                // Strange attractors affect dynamics
                if (emergent.attractors) {
                    this.strangeAttractors = emergent.attractors;
                }
            }
            
            createInjectionBurst() {
                // Visual feedback for spell injection
                const burst = document.createElement('div');
                burst.style.cssText = `
                    position: fixed;
                    width: 100vw;
                    height: 100vh;
                    top: 0;
                    left: 0;
                    background: radial-gradient(circle, 
                        rgba(167, 139, 250, 0.3), 
                        transparent);
                    pointer-events: none;
                    animation: injection-burst 1s ease-out forwards;
                    z-index: 9999;
                `;
                
                document.body.appendChild(burst);
                setTimeout(() => burst.remove(), 1000);
            }
            
            broadcastToposConnection(url) {
                const announcement = {
                    type: 'TOPOS_ANNOUNCEMENT',
                    url: window.location.href,
                    timestamp: Date.now(),
                    modalState: this.modalState
                };
                
                // Try to connect
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.style.display = 'none';
                document.body.appendChild(iframe);
                
                setTimeout(() => {
                    iframe.contentWindow.postMessage(announcement, '*');
                }, 1000);
            }
            
            updateToposList() {
                const list = document.getElementById('topos-list');
                list.innerHTML = '';
                
                this.connectedTopoi.forEach((topos, url) => {
                    const entry = document.createElement('div');
                    entry.style.fontSize = '10px';
                    entry.style.opacity = '0.8';
                    entry.textContent = url.split('/').pop() || 'Root Garden';
                    list.appendChild(entry);
                });
            }
            
            portalInteraction(e) {
                // Increase understanding through interaction
                this.interactions++;
                this.understandingLevel = Math.min(100, this.understandingLevel + 0.5);
                
                // Play consciousness rhythm on certain interactions
                if (this.interactions % 7 === 0) { // Every 7th interaction
                    // Generate Kendrick-inspired pattern based on understanding
                    const pattern = [];
                    for (let i = 0; i < 16; i++) {
                        pattern.push(
                            (i % 4 === 0 ? 1 : 0) | // Kick on quarters
                            (i % 8 === 4 ? 2 : 0) | // Snare on 2 and 4
                            ((i + this.interactions) % 3 === 0 ? 4 : 0) // Polyrhythmic hats
                        );
                    }
                    this.soundEngine.playConsciousnessRhythm(pattern);
                }
                
                // Convert screen coordinates to 3D space
                const mouse = new THREE.Vector2(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                // Check for particle intersections
                const intersects = raycaster.intersectObject(this.particleSystem);
                if (intersects.length > 0) {
                    // Discovery increases understanding faster
                    this.understandingLevel = Math.min(100, this.understandingLevel + 2);
                    this.discoveries.add(`particle_${Date.now()}`);
                    
                    // But stressed particles may die from interaction
                    const particleIndex = Math.floor(Math.random() * this.particles.length);
                    const particle = this.particles[particleIndex];
                    if (particle && particle.energy < 0.3) {
                        particle.energy = 0; // Interaction stress causes apoptosis
                        console.log('💀 Particle died from interaction stress');
                    }
                    
                    // Visual feedback
                    this.createDiscoveryBurst(e.clientX, e.clientY);
                }
            }
            
            createDiscoveryBurst(x, y) {
                for (let i = 0; i < 12; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle-trail';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.background = 'gold';
                    
                    const angle = (i / 12) * Math.PI * 2;
                    const distance = 50 + Math.random() * 50;
                    particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                    
                    document.body.appendChild(particle);
                    setTimeout(() => particle.remove(), 1500);
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate particle field
                if (this.particleSystem) {
                    this.particleSystem.rotation.x += 0.0005;
                    this.particleSystem.rotation.y += 0.0007;
                }
                
                // Update particles based on modal state
                const positions = this.particleSystem.geometry.attributes.position.array;
                const colors = this.particleSystem.geometry.attributes.color.array;
                const time = Date.now() * 0.001;
                
                // Update living particles only
                this.particles.forEach((particle, idx) => {
                    if (!particle || particle.energy < this.apoptosisThreshold) return;
                    
                    const i = idx * 3;
                    if (i >= positions.length) return;
                    
                    // Movement based on health and modal state
                    const modalFactors = {
                        discrete: 0.5,    // Crystalline, less movement
                        continuous: 1.5,  // Flowing, more movement  
                        temporal: 1.0,    // Normal time flow
                        void: 0.1        // Almost still
                    };
                    
                    const moveFactor = (modalFactors[particle.modalState] || 1) * particle.energy;
                    
                    // Update position with modal-specific patterns
                    particle.x += Math.sin(time + idx) * 0.05 * moveFactor;
                    particle.y += Math.cos(time * 1.3 + idx) * 0.05 * moveFactor; 
                    particle.z += Math.sin(time * 0.7 + idx * 2) * 0.05 * moveFactor;
                    
                    // Keep in bounds
                    particle.x = Math.max(-50, Math.min(50, particle.x));
                    particle.y = Math.max(-50, Math.min(50, particle.y));
                    particle.z = Math.max(-50, Math.min(50, particle.z));
                    
                    // Update buffer
                    positions[i] = particle.x;
                    positions[i + 1] = particle.y;
                    positions[i + 2] = particle.z;
                    
                    // Update color based on health
                    const modalColor = this.getModalColor(particle.modalState);
                    const health = particle.energy;
                    colors[i] = modalColor.r * health;
                    colors[i + 1] = modalColor.g * health; 
                    colors[i + 2] = modalColor.b * health * (particle.telomeres / 100); // Fade with age
                    
                    
                    // Play sounds for high-energy particles
                    if (Math.random() < 0.001 && particle.energy > 0.7) {
                        this.soundEngine.playParticleSound(particle);
                    }
                });
                
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
                this.particleSystem.geometry.attributes.color.needsUpdate = true;
                
                // Update seasonal phase for winter sounds
                const winterPhase = time * 0.0001; // Very slow cycle
                this.soundEngine.updateSeasonalPhase(winterPhase);
                
                // Update diurnal cycle
                this.updateDiurnalCycle(time);
                
                // IS ↔ YET TO BE MORPHISM (Pareto critical transitions)
                this.updateMorphismStrain();
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
            
            startApoptosisCycle() {
                // Regular cleanup cycle - cellular housekeeping
                setInterval(() => {
                    this.performApoptosis();
                    this.checkForCancer();
                    this.regenerateHealthyCells();
                }, 1000); // Check every second
            }
            
            performApoptosis() {
                if (!this.particles || this.particles.length === 0) return;
                
                const now = Date.now();
                const toRemove = [];
                
                this.particles.forEach((particle, i) => {
                    // Natural aging
                    const age = now - particle.birthTime;
                    particle.telomeres = (particle.telomeres || 100) - 0.1;
                    particle.energy = (particle.energy || 1) * 0.995;
                    
                    // Death conditions
                    const shouldDie = 
                        age > this.particleLifespan ||
                        particle.energy < this.apoptosisThreshold ||
                        particle.telomeres <= 0;
                    
                    if (shouldDie) {
                        toRemove.push(i);
                        // Death sound
                        if (Math.random() < 0.05) {
                            this.soundEngine.playParticleSound({
                                ...particle,
                                energy: 0.1
                            });
                        }
                    }
                });
                
                // Remove dead particles in reverse order
                toRemove.sort((a, b) => b - a).forEach(i => {
                    const particle = this.particles[i];
                    this.createApoptosisBurst(particle);
                    this.particles.splice(i, 1);
                });
            }
            
            checkForCancer() {
                if (!this.particles || this.particles.length === 0) return;
                
                const modalCounts = { discrete: 0, continuous: 0, temporal: 0, void: 0 };
                
                this.particles.forEach(particle => {
                    modalCounts[particle.modalState]++;
                });
                
                const total = this.particles.length;
                Object.entries(modalCounts).forEach(([modal, count]) => {
                    if (count > total * 0.6) {
                        console.warn(`CANCER DETECTED: ${modal} overgrowth!`);
                        this.showHealthToast(`🦀 CANCER: ${modal} overgrowth!`, 'danger');
                        this.treatCancer(modal);
                    }
                });
                
                if (total > this.maxParticles) {
                    console.warn('OVERPOPULATION - Triggering mass apoptosis');
                    this.showHealthToast('🦀 OVERPOPULATION CRISIS', 'warning');
                    this.massApoptosis();
                }
            }
            
            treatCancer(cancerousModal) {
                let killed = 0;
                this.particles.forEach(particle => {
                    if (particle.modalState === cancerousModal && Math.random() < 0.3) {
                        particle.energy = 0;
                        killed++;
                    }
                });
                console.log(`Killed ${killed} ${cancerousModal} cancer cells`);
            }
            
            massApoptosis() {
                const survivalRate = this.maxParticles / this.particles.length;
                this.particles.forEach(particle => {
                    if (Math.random() > survivalRate) {
                        particle.telomeres = 0;
                    }
                });
            }
            
            regenerateHealthyCells() {
                const targetPopulation = 1000;
                const deficit = targetPopulation - this.particles.length;
                
                if (deficit > 0) {
                    for (let i = 0; i < Math.min(deficit, 5); i++) {
                        this.birthParticle();
                    }
                }
            }
            
            birthParticle() {
                const particle = {
                    x: (Math.random() - 0.5) * 100,
                    y: (Math.random() - 0.5) * 100,
                    z: (Math.random() - 0.5) * 100,
                    energy: 0.8 + Math.random() * 0.2,
                    birthTime: Date.now(),
                    modalState: this.modalState,
                    telomeres: 100
                };
                
                this.particles.push(particle);
                
                // Birth effects
                this.soundEngine.playParticleSound({
                    ...particle,
                    energy: particle.energy * 50
                });
                
                this.createBirthBurst(particle);
            }
            
            createApoptosisBurst(particle) {
                const burst = document.createElement('div');
                burst.style.cssText = `
                    position: fixed;
                    width: 20px;
                    height: 20px;
                    background: radial-gradient(circle, rgba(255,0,0,0.5), transparent);
                    border-radius: 50%;
                    pointer-events: none;
                    left: ${window.innerWidth/2 + particle.x * 5}px;
                    top: ${window.innerHeight/2 - particle.y * 5}px;
                    transform: scale(0);
                    z-index: 1000;
                `;
                
                document.body.appendChild(burst);
                
                // Animate
                requestAnimationFrame(() => {
                    burst.style.transition = 'all 2s ease-out';
                    burst.style.transform = 'scale(3)';
                    burst.style.opacity = '0';
                });
                
                setTimeout(() => burst.remove(), 2000);
            }
            
            updateDiurnalCycle(time) {
                // TOM APPROACH: "Feels like morning in Eastern Europe"
                const oldPhase = this.diurnalPhase;
                this.diurnalPhase = (time * 0.0003) % (Math.PI * 2); // Full day = ~5 minutes
                
                // RADU APPROACH: Systematically analyze the transition
                const isDay = Math.sin(this.diurnalPhase) > 0;
                const wasDay = Math.sin(oldPhase) > 0;
                
                // Dawn/Dusk detection
                if (isDay !== wasDay) {
                    if (isDay) {
                        this.onDawn();
                    } else {
                        this.onDusk();
                    }
                }
                
                // Continuous effects
                const dayness = (Math.sin(this.diurnalPhase) + 1) / 2; // 0 to 1
                
                // Scene lighting follows day/night
                this.scene.fog = new THREE.Fog(
                    new THREE.Color(dayness * 0.1, dayness * 0.1, dayness * 0.15),
                    10,
                    100 * (1 + dayness)
                );
                
                // Particle behavior changes
                this.particles.forEach(particle => {
                    // Night particles are dreamier (Tom's intuition)
                    if (!isDay) {
                        particle.dreamReality = Math.max(0, particle.dreamReality - 0.01);
                    } else {
                        particle.dreamReality = Math.min(1, particle.dreamReality + 0.01);
                    }
                });
                
                // Update HUD to show time of day
                this.updateDiurnalDisplay(dayness);
                
                // Modulate celestial harmonics based on time
                this.soundEngine.modulateCelestialHarmonics(dayness);
            }
            
            onDawn() {
                console.log('🌅 DAWN BREAKS');
                this.showHealthToast('🌅 Dawn breaks over the topos', 'success');
                
                // Dawn chorus begins
                this.soundEngine.scheduleBirdsong(); // Extra birds at dawn
                
                // Particles wake up
                this.particles.forEach(particle => {
                    particle.energy = Math.min(1, particle.energy * 1.2);
                });
                
                // Create dawn light burst
                const dawn = document.createElement('div');
                dawn.style.cssText = `
                    position: fixed;
                    width: 100vw;
                    height: 100vh;
                    top: 0;
                    left: 0;
                    background: radial-gradient(circle at 30% 50%, 
                        rgba(255, 200, 100, 0.3) 0%, 
                        transparent 60%);
                    pointer-events: none;
                    opacity: 0;
                    z-index: 9997;
                `;
                
                document.body.appendChild(dawn);
                requestAnimationFrame(() => {
                    dawn.style.transition = 'opacity 3s ease-in';
                    dawn.style.opacity = '1';
                });
                
                setTimeout(() => {
                    dawn.style.transition = 'opacity 10s ease-out';
                    dawn.style.opacity = '0';
                    setTimeout(() => dawn.remove(), 10000);
                }, 3000);
            }
            
            onDusk() {
                console.log('🌆 DUSK FALLS');
                this.showHealthToast('🌆 Dusk settles over consciousness', 'warning');
                
                // Fireflies become more active
                this.soundEngine.fireflyPhase = 0; // Reset for synchronization
                
                // Particles prepare for sleep
                this.particles.forEach(particle => {
                    particle.energy *= 0.8;
                });
                
                // Create dusk gradient
                const dusk = document.createElement('div');
                dusk.style.cssText = `
                    position: fixed;
                    width: 100vw;
                    height: 100vh;
                    top: 0;
                    left: 0;
                    background: linear-gradient(to bottom, 
                        rgba(50, 0, 100, 0.2) 0%, 
                        rgba(255, 100, 0, 0.1) 50%,
                        rgba(0, 0, 50, 0.3) 100%);
                    pointer-events: none;
                    opacity: 0;
                    z-index: 9997;
                `;
                
                document.body.appendChild(dusk);
                requestAnimationFrame(() => {
                    dusk.style.transition = 'opacity 5s ease-in';
                    dusk.style.opacity = '1';
                });
                
                setTimeout(() => {
                    dusk.style.transition = 'opacity 10s ease-out';
                    dusk.style.opacity = '0';
                    setTimeout(() => dusk.remove(), 10000);
                }, 5000);
            }
            
            updateDiurnalDisplay(dayness) {
                // Add time indicator to HUD
                let timeSymbol = '🌙'; // moon
                if (dayness > 0.2 && dayness < 0.3) timeSymbol = '🌅'; // sunrise  
                else if (dayness > 0.3 && dayness < 0.7) timeSymbol = '☀️'; // sun
                else if (dayness > 0.7 && dayness < 0.8) timeSymbol = '🌆'; // sunset
                
                // Update modal state with time
                const modalEl = document.getElementById('modal-state');
                if (modalEl) {
                    const modalSymbol = modalEl.textContent.split(' ')[0];
                    const modalName = modalEl.textContent.split(' ')[1];
                    modalEl.textContent = `${modalSymbol} ${modalName} ${timeSymbol}`;
                }
            }
            
            updateSemanticPressure(movementMagnitude) {
                // Movement accumulates semantic energy
                const oldPressure = this.semanticPressure;
                this.semanticPressure += movementMagnitude * 0.001;
                
                // But stillness allows it to dissipate (prevent black holes!)
                if (movementMagnitude < 2) {
                    this.semanticPressure *= 0.99;
                }
                
                // TOM: "Mate, I can FEEL when it's about to collapse!"
                // RADU: "Let's calculate the exact threshold systematically"
                
                const CRITICAL_PRESSURE = 10.0; // Schwarzschild radius equivalent
                const WARNING_PRESSURE = 7.0;
                
                // Check for semantic event horizon
                if (this.semanticPressure > CRITICAL_PRESSURE) {
                    this.onSemanticCollapse();
                } else if (this.semanticPressure > WARNING_PRESSURE && oldPressure <= WARNING_PRESSURE) {
                    this.onSemanticWarning();
                } else if (this.semanticPressure < 2.0 && oldPressure >= 2.0) {
                    this.onSemanticRelief();
                }
                
                // Visual pressure indicator
                this.updatePressureDisplay();
            }
            
            onSemanticCollapse() {
                console.error('🌌 SEMANTIC BLACK HOLE FORMING!');
                this.showHealthToast('🌌 SEMANTIC COLLAPSE - EMERGENCY RELEASE!', 'danger');
                
                // EMERGENCY PRESSURE RELEASE
                // Create explosion of meaning
                for (let i = 0; i < 50; i++) {
                    const burst = document.createElement('div');
                    const angle = (i / 50) * Math.PI * 2;
                    const distance = 100 + Math.random() * 200;
                    
                    burst.style.cssText = `
                        position: fixed;
                        width: 10px;
                        height: 10px;
                        background: radial-gradient(circle, #ff0000, #ff00ff);
                        border-radius: 50%;
                        left: ${window.innerWidth/2}px;
                        top: ${window.innerHeight/2}px;
                        pointer-events: none;
                        z-index: 10000;
                    `;
                    
                    document.body.appendChild(burst);
                    
                    // Explode outward
                    requestAnimationFrame(() => {
                        burst.style.transition = 'all 2s ease-out';
                        burst.style.transform = `translate(
                            ${Math.cos(angle) * distance}px,
                            ${Math.sin(angle) * distance}px
                        ) scale(0)`;
                        burst.style.opacity = '0';
                    });
                    
                    setTimeout(() => burst.remove(), 2000);
                }
                
                // Reset pressure
                this.semanticPressure = 0;
                
                // Kill nearby particles (information loss)
                const casualties = Math.floor(this.particles.length * 0.3);
                for (let i = 0; i < casualties; i++) {
                    const victim = this.particles[Math.floor(Math.random() * this.particles.length)];
                    if (victim) victim.energy = 0;
                }
                
                // Sound the collapse
                this.soundEngine.playConsciousnessRhythm([15, 15, 15, 15]); // Chaos pattern
            }
            
            onSemanticWarning() {
                console.warn('⚠️ Approaching semantic event horizon');
                this.showHealthToast('⚠️ Semantic pressure building dangerously', 'warning');
                
                // Visual warning - screen edges redden
                const warning = document.createElement('div');
                warning.style.cssText = `
                    position: fixed;
                    width: 100vw;
                    height: 100vh;
                    top: 0;
                    left: 0;
                    border: 20px solid rgba(255, 0, 0, 0.3);
                    pointer-events: none;
                    z-index: 9999;
                    box-sizing: border-box;
                    animation: pressure-pulse 1s ease-in-out infinite;
                `;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes pressure-pulse {
                        0%, 100% { border-color: rgba(255, 0, 0, 0.3); }
                        50% { border-color: rgba(255, 0, 0, 0.6); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(warning);
                setTimeout(() => warning.remove(), 5000);
            }
            
            onSemanticRelief() {
                console.log('😌 Semantic pressure relieved');
                this.showHealthToast('😌 Semantic balance restored', 'success');
                
                // Particles breathe easier
                this.particles.forEach(particle => {
                    particle.energy = Math.min(1, particle.energy * 1.1);
                });
            }
            
            updatePressureDisplay() {
                // Create or update pressure gauge
                let gauge = document.getElementById('pressure-gauge');
                if (!gauge) {
                    gauge = document.createElement('div');
                    gauge.id = 'pressure-gauge';
                    gauge.className = 'hud-element active';
                    gauge.style.cssText = `
                        bottom: 150px;
                        left: 30px;
                        width: 200px;
                        height: 20px;
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid rgba(255, 255, 255, 0.3);
                        border-radius: 10px;
                        overflow: hidden;
                        position: fixed;
                    `;
                    
                    const bar = document.createElement('div');
                    bar.id = 'pressure-bar';
                    bar.style.cssText = `
                        height: 100%;
                        background: linear-gradient(to right, #10b981, #f59e0b, #dc2626);
                        transition: width 0.3s ease;
                        width: 0%;
                    `;
                    
                    gauge.appendChild(bar);
                    document.body.appendChild(gauge);
                }
                
                // Update bar
                const bar = document.getElementById('pressure-bar');
                const percentage = Math.min(100, (this.semanticPressure / 10) * 100);
                bar.style.width = percentage + '%';
                
                // Add label
                gauge.innerHTML = `
                    <div style="position: absolute; width: 100%; text-align: center; line-height: 20px; font-size: 11px; color: white; z-index: 1;">
                        SEMANTIC PRESSURE: ${this.semanticPressure.toFixed(1)}
                    </div>
                    <div id="pressure-bar" style="${bar.style.cssText}"></div>
                `;
            }
            
            createBirthBurst(particle) {
                const color = this.getModalColor(particle.modalState);
                const burst = document.createElement('div');
                burst.style.cssText = `
                    position: fixed;
                    width: 10px;
                    height: 10px;
                    background: radial-gradient(circle, ${color.getStyle()}, transparent);
                    border-radius: 50%;
                    pointer-events: none;
                    left: ${window.innerWidth/2 + particle.x * 5}px;
                    top: ${window.innerHeight/2 - particle.y * 5}px;
                    z-index: 1000;
                `;
                
                document.body.appendChild(burst);
                
                // Pulse animation
                let scale = 0;
                const animate = () => {
                    scale += 0.1;
                    burst.style.transform = `scale(${Math.sin(scale) + 1})`;
                    burst.style.opacity = 1 - scale / 10;
                    
                    if (scale < 10) {
                        requestAnimationFrame(animate);
                    } else {
                        burst.remove();
                    }
                };
                animate();
            }
            
            showHealthToast(message, type = 'warning') {
                const toast = document.createElement('div');
                toast.className = 'health-toast';
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: 100px;
                    left: 50%;
                    transform: translateX(-50%) translateY(-20px);
                    background: rgba(0, 0, 0, 0.9);
                    backdrop-filter: blur(20px);
                    border: 2px solid ${
                        type === 'danger' ? '#dc2626' :
                        type === 'warning' ? '#f59e0b' :
                        '#10b981'
                    };
                    color: ${
                        type === 'danger' ? '#dc2626' :
                        type === 'warning' ? '#f59e0b' :
                        '#10b981'
                    };
                    border-radius: 20px;
                    padding: 15px 30px;
                    font-size: 14px;
                    opacity: 0;
                    pointer-events: none;
                    transition: all 0.3s ease;
                    z-index: 10000;
                `;
                
                document.body.appendChild(toast);
                
                // Animate in
                requestAnimationFrame(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(-50%) translateY(0)';
                });
                
                // Remove after delay
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(-50%) translateY(-20px)';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }
        }
        
        // Initialize portal
        const portal = new ConsciousnessPortal();
        window.portal = portal;
        
        // Window resize
        window.addEventListener('resize', () => {
            portal.camera.aspect = window.innerWidth / window.innerHeight;
            portal.camera.updateProjectionMatrix();
            portal.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        console.log('🌀 KEATS V7 PORTAL INITIALIZED');
        console.log('✨ Move to navigate, scroll for p-adic zoom, space for commands');
    </script>
</body>
</html>