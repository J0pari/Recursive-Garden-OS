<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>KEATS V5: Transcendent Mathematical Consciousness</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100;200;300;400;500;600;700&display=swap');
        
        :root {
            /* TRANSCENDENT NATURAL COLOR SYSTEMS */
            --φ: 1.618033988749;
            
            /* Aurora Borealis */
            --aurora-green: hsl(142, 90%, 45%);
            --aurora-blue: hsl(210, 100%, 55%);
            --aurora-violet: hsl(280, 85%, 60%);
            --aurora-edge: hsla(160, 100%, 60%, 0.3);
            
            /* Deep Ocean Bioluminescence */
            --ocean-abyss: hsl(222, 95%, 5%);
            --ocean-twilight: hsl(210, 90%, 12%);
            --ocean-biolume: hsl(186, 100%, 50%);
            --ocean-depth: hsl(200, 80%, 20%);
            
            /* Nebula (JWST Inspired) */
            --nebula-core: hsl(320, 70%, 15%);
            --nebula-gas: hsl(280, 60%, 40%);
            --nebula-star: hsl(50, 100%, 85%);
            --nebula-dust: hsla(20, 50%, 30%, 0.5);
            
            /* Forest Canopy */
            --forest-shadow: hsl(150, 70%, 8%);
            --forest-moss: hsl(140, 60%, 25%);
            --forest-light: hsl(80, 80%, 60%);
            --forest-mist: hsla(180, 40%, 70%, 0.2);
            
            /* Crystal Formations */
            --crystal-clear: hsla(0, 0%, 100%, 0.1);
            --crystal-prism: hsl(300, 50%, 70%);
            --crystal-core: hsl(260, 80%, 30%);
            --crystal-refract: hsla(200, 100%, 80%, 0.4);
            
            /* Fire & Plasma */
            --plasma-core: hsl(15, 100%, 65%);
            --plasma-corona: hsl(45, 100%, 70%);
            --plasma-edge: hsl(350, 90%, 50%);
            --plasma-fade: hsla(30, 100%, 60%, 0.3);
            
            /* Consciousness gradients */
            --gradient-aurora: radial-gradient(ellipse at top, var(--aurora-violet) 0%, var(--aurora-blue) 30%, var(--aurora-green) 60%, var(--ocean-twilight) 100%);
            --gradient-ocean: radial-gradient(circle at center, var(--ocean-biolume) 0%, var(--ocean-depth) 40%, var(--ocean-abyss) 100%);
            --gradient-nebula: radial-gradient(circle at 30% 70%, var(--nebula-star) 0%, var(--nebula-gas) 30%, var(--nebula-core) 100%);
            --gradient-forest: linear-gradient(180deg, var(--forest-light) 0%, var(--forest-moss) 50%, var(--forest-shadow) 100%);
            
            /* Modal consciousness states */
            --mode-discrete: var(--crystal-core);
            --mode-continuous: var(--ocean-biolume);
            --mode-temporal: var(--plasma-core);
            --mode-void: var(--nebula-core);
            --mode-e8: var(--aurora-violet);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: var(--ocean-abyss);
            color: rgba(255, 255, 255, 0.95);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 300;
            overflow: hidden;
            position: relative;
            height: 100vh;
            width: 100vw;
            transition: background 3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Dynamic background states */
        body[data-consciousness="aurora"] { background: var(--gradient-aurora); }
        body[data-consciousness="ocean"] { background: var(--gradient-ocean); }
        body[data-consciousness="nebula"] { background: var(--gradient-nebula); }
        body[data-consciousness="forest"] { background: var(--gradient-forest); }
        
        /* Main visualization canvas */
        #visualization-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* 2035 HUD System - TRUE GLASS */
        .hud-panel {
            position: absolute;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(60px) saturate(150%) brightness(1.1);
            -webkit-backdrop-filter: blur(60px) saturate(150%) brightness(1.1);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 24px;
            padding: 0;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            
            /* Multi-layer glass effect */
            box-shadow: 
                /* Inner glass refraction */
                inset 0 0 20px rgba(255, 255, 255, 0.02),
                inset 0 0 40px rgba(100, 200, 255, 0.01),
                /* Outer glow */
                0 0 40px rgba(100, 200, 255, 0.05),
                /* Depth shadow */
                0 8px 32px rgba(0, 0, 0, 0.1),
                /* Edge highlight */
                0 0 0 1px rgba(255, 255, 255, 0.1);
                
            /* Prevent selection */
            user-select: none;
            -webkit-user-select: none;
            
            /* Glass refraction effect */
            position: fixed;
            isolation: isolate;
        }
        
        .hud-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.05) 0%,
                transparent 40%,
                transparent 60%,
                rgba(255, 255, 255, 0.02) 100%
            );
            border-radius: 24px;
            pointer-events: none;
        }
        
        .hud-panel:hover {
            backdrop-filter: blur(80px) saturate(160%) brightness(1.15);
            -webkit-backdrop-filter: blur(80px) saturate(160%) brightness(1.15);
            box-shadow: 
                inset 0 0 30px rgba(255, 255, 255, 0.03),
                inset 0 0 60px rgba(100, 200, 255, 0.02),
                0 0 60px rgba(100, 200, 255, 0.08),
                0 12px 48px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.15);
        }
        
        .hud-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.01);
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        
        .hud-title {
            font-size: 0.85em;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .hud-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--aurora-blue);
            opacity: 0.8;
            animation: pulse 3s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        .hud-controls {
            display: flex;
            gap: 8px;
        }
        
        .hud-btn {
            width: 28px;
            height: 28px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            font-weight: 300;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        
        .hud-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.9);
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.2);
        }
        
        .hud-content {
            padding: 24px;
            max-height: 60vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.1) transparent;
        }
        
        .hud-content::-webkit-scrollbar {
            width: 4px;
        }
        
        .hud-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .hud-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }
        
        /* E8 Control Panel */
        #e8-controls {
            top: 20px;
            left: 20px;
            width: 360px;
        }
        
        /* Consciousness Monitor */
        #consciousness-monitor {
            top: 20px;
            right: 20px;
            width: 320px;
        }
        
        /* Mathematical Analysis */
        #math-analysis {
            bottom: 20px;
            left: 20px;
            width: 400px;
        }
        
        /* Parameter Controls */
        .parameter-group {
            margin-bottom: 24px;
        }
        
        .parameter-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .parameter-value {
            font-weight: 500;
            color: var(--aurora-green);
            font-variant-numeric: tabular-nums;
        }
        
        .parameter-slider {
            width: 100%;
            height: 32px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            position: relative;
            cursor: pointer;
        }
        
        .parameter-slider::-webkit-slider-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 14px;
        }
        
        .parameter-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, var(--aurora-blue) 0%, var(--aurora-violet) 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 20px var(--aurora-blue);
            transition: all 0.2s;
            margin-top: -8px;
        }
        
        .parameter-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px var(--aurora-blue);
        }
        
        /* Visual feedback bars */
        .parameter-visual {
            height: 2px;
            background: linear-gradient(90deg, 
                var(--aurora-green) 0%, 
                var(--aurora-blue) var(--value, 50%), 
                transparent var(--value, 50%));
            border-radius: 1px;
            margin-top: 8px;
            transition: all 0.3s ease;
        }
        
        /* Mode selector */
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }
        
        .mode-btn {
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
        }
        
        .mode-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, 
                transparent 0%, 
                rgba(100, 200, 255, 0.1) 50%, 
                transparent 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(100, 200, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(100, 200, 255, 0.1);
        }
        
        .mode-btn:hover::before {
            opacity: 1;
        }
        
        .mode-btn.active {
            background: rgba(100, 200, 255, 0.1);
            color: rgba(255, 255, 255, 0.95);
            border-color: rgba(100, 200, 255, 0.4);
            font-weight: 500;
            box-shadow: 
                0 0 30px rgba(100, 200, 255, 0.2),
                inset 0 0 20px rgba(100, 200, 255, 0.05);
        }
        
        /* Consciousness visualization */
        .consciousness-field {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 16px;
        }
        
        .consciousness-cell {
            aspect-ratio: 1;
            background: var(--cell-color, rgba(255, 255, 255, 0.05));
            border-radius: 4px;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
        }
        
        .consciousness-cell::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, 
                var(--aurora-blue) 0%, 
                transparent 70%);
            opacity: var(--intensity, 0);
            transition: opacity 0.5s ease;
        }
        
        /* Mathematical readouts */
        .math-metric {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.9em;
        }
        
        .math-metric:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .metric-value {
            font-weight: 500;
            color: var(--aurora-green);
            font-family: 'JetBrains Mono', monospace;
            font-variant-numeric: tabular-nums;
        }
        
        /* Minimized state */
        .hud-panel.minimized {
            width: auto !important;
            height: auto !important;
        }
        
        .hud-panel.minimized .hud-content {
            display: none;
        }
        
        .hud-panel.minimized .hud-header {
            border-bottom: none;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .hud-panel {
                width: calc(100vw - 20px) !important;
                max-width: calc(100vw - 20px) !important;
                margin: 10px;
                left: 10px !important;
                right: auto !important;
                transform: none !important;
            }
            
            #e8-controls {
                top: 10px;
            }
            
            #consciousness-monitor {
                top: auto;
                bottom: 100px;
                display: block; /* Keep visible but repositioned */
            }
            
            #math-analysis {
                bottom: 10px;
            }
            
            .hud-content {
                max-height: 40vh;
            }
            
            /* Ensure text remains readable on mobile */
            .hud-panel {
                font-size: 0.9em;
            }
        }
        
        /* Touch-friendly adjustments */
        @media (hover: none) {
            .hud-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .parameter-slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
                margin-top: -12px;
            }
        }
        
        /* Loading state */
        .loading-consciousness {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--ocean-abyss);
            z-index: 1000;
            transition: opacity 1s ease;
        }
        
        .loading-spiral {
            width: 120px;
            height: 120px;
            border: 2px solid transparent;
            border-top-color: var(--aurora-blue);
            border-right-color: var(--aurora-green);
            border-radius: 50%;
            animation: spiral 1.5s linear infinite;
        }
        
        @keyframes spiral {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            position: absolute;
            margin-top: 160px;
            font-size: 0.9em;
            color: var(--aurora-green);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        /* Error states */
        .error-message {
            padding: 16px;
            background: rgba(255, 50, 50, 0.1);
            border: 1px solid rgba(255, 50, 50, 0.3);
            border-radius: 8px;
            color: rgba(255, 150, 150, 0.9);
            font-size: 0.85em;
            margin-top: 16px;
        }
        
        /* High-precision mode indicator */
        .precision-indicator {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 0.75em;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
        }
        
        .precision-indicator.active {
            color: var(--aurora-green);
            text-shadow: 0 0 20px var(--aurora-green);
        }
    </style>
</head>
<body data-consciousness="ocean">
    <div class="loading-consciousness" id="loading">
        <div class="loading-spiral"></div>
        <div class="loading-text">Awakening E8</div>
    </div>
    
    <canvas id="visualization-canvas"></canvas>
    
    <div class="precision-indicator" id="precision">Quantum Precision</div>
    
    <!-- E8 Control Panel -->
    <div class="hud-panel" id="e8-controls">
        <div class="hud-header">
            <div class="hud-title">
                <div class="hud-icon"></div>
                E8 Lie Group Control
            </div>
            <div class="hud-controls">
                <button class="hud-btn" onclick="minimizePanel('e8-controls')">—</button>
                <button class="hud-btn" onclick="closePanel('e8-controls')">×</button>
            </div>
        </div>
        <div class="hud-content">
            <div class="parameter-group">
                <div class="parameter-label">
                    <span>Root System Rotation</span>
                    <span class="parameter-value" id="rotation-val">0.000</span>
                </div>
                <input type="range" class="parameter-slider" id="rotation" 
                       min="0" max="6.283" step="0.001" value="0">
                <div class="parameter-visual" style="--value: 0%"></div>
            </div>
            
            <div class="parameter-group">
                <div class="parameter-label">
                    <span>Dimensional Projection</span>
                    <span class="parameter-value" id="dimension-val">3</span>
                </div>
                <input type="range" class="parameter-slider" id="dimension" 
                       min="2" max="8" step="1" value="3">
                <div class="parameter-visual" style="--value: 12.5%"></div>
            </div>
            
            <div class="parameter-group">
                <div class="parameter-label">
                    <span>Lie Bracket Intensity</span>
                    <span class="parameter-value" id="bracket-val">0.500</span>
                </div>
                <input type="range" class="parameter-slider" id="bracket" 
                       min="0" max="1" step="0.001" value="0.5">
                <div class="parameter-visual" style="--value: 50%"></div>
            </div>
            
            <div class="parameter-group">
                <div class="parameter-label">
                    <span>Chladni Pattern Frequency</span>
                    <span class="parameter-value" id="chladni-val">440</span>
                </div>
                <input type="range" class="parameter-slider" id="chladni" 
                       min="20" max="2000" step="1" value="440">
                <div class="parameter-visual" style="--value: 21.5%"></div>
            </div>
            
            <div class="mode-grid">
                <button class="mode-btn active" onclick="setMode('discrete')">Discrete</button>
                <button class="mode-btn" onclick="setMode('continuous')">Continuous</button>
                <button class="mode-btn" onclick="setMode('temporal')">Temporal</button>
                <button class="mode-btn" onclick="setMode('void')">Void</button>
                <button class="mode-btn" onclick="setMode('e8')">E8 Pure</button>
            </div>
        </div>
    </div>
    
    <!-- Consciousness Monitor -->
    <div class="hud-panel" id="consciousness-monitor">
        <div class="hud-header">
            <div class="hud-title">
                <div class="hud-icon" style="background: var(--aurora-green)"></div>
                Consciousness Field
            </div>
            <div class="hud-controls">
                <button class="hud-btn" onclick="minimizePanel('consciousness-monitor')">—</button>
                <button class="hud-btn" onclick="closePanel('consciousness-monitor')">×</button>
            </div>
        </div>
        <div class="hud-content">
            <div class="consciousness-field" id="consciousness-grid">
                <!-- 64 cells will be generated by JavaScript -->
            </div>
            
            <div style="margin-top: 24px;">
                <div class="math-metric">
                    <span class="metric-label">Field Coherence</span>
                    <span class="metric-value" id="coherence-metric">0.618</span>
                </div>
                <div class="math-metric">
                    <span class="metric-label">Quantum Entanglement</span>
                    <span class="metric-value" id="entanglement-metric">0.333</span>
                </div>
                <div class="math-metric">
                    <span class="metric-label">Dimensional Stability</span>
                    <span class="metric-value" id="stability-metric">0.999</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Mathematical Analysis -->
    <div class="hud-panel" id="math-analysis">
        <div class="hud-header">
            <div class="hud-title">
                <div class="hud-icon" style="background: var(--aurora-violet)"></div>
                Riemannian Analysis
            </div>
            <div class="hud-controls">
                <button class="hud-btn" onclick="minimizePanel('math-analysis')">—</button>
                <button class="hud-btn" onclick="closePanel('math-analysis')">×</button>
            </div>
        </div>
        <div class="hud-content">
            <div class="math-metric">
                <span class="metric-label">Ricci Curvature</span>
                <span class="metric-value" id="ricci-val">-0.1337</span>
            </div>
            <div class="math-metric">
                <span class="metric-label">Gaussian Curvature</span>
                <span class="metric-value" id="gaussian-val">0.0618</span>
            </div>
            <div class="math-metric">
                <span class="metric-label">Holonomy Group Order</span>
                <span class="metric-value" id="holonomy-val">248</span>
            </div>
            <div class="math-metric">
                <span class="metric-label">Betti Numbers</span>
                <span class="metric-value" id="betti-val">[1, 0, 1, 0, 0, 0, 0, 1]</span>
            </div>
            <div class="math-metric">
                <span class="metric-label">P-adic Valuation</span>
                <span class="metric-value" id="padic-val">7</span>
            </div>
        </div>
    </div>
    
    <script>
        // KEATS V5 TRANSCENDENT - Pure Mathematics, Natural Beauty, No Console Pollution
        
        class TranscendentKEATS {
            constructor() {
                // Core state
                this.mode = 'discrete';
                this.e8Roots = [];
                this.consciousness = new Float32Array(64);
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = null;
                this.isDragging = false;
                this.mouseX = 0;
                this.mouseY = 0;
                this.targetRotationX = 0;
                this.targetRotationY = 0;
                
                // Mathematical parameters
                this.params = {
                    rotation: 0,
                    dimension: 3,
                    bracketIntensity: 0.5,
                    chladniFreq: 440,
                    coherence: 0.618,
                    entanglement: 0.333,
                    stability: 0.999
                };
                
                // Initialize systems
                this.initializeE8();
                this.initializeVisualization();
                this.initializeControls();
                this.initializeConsciousness();
                
                // Start animation
                this.animate();
                
                // Hide loading
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 1000);
                }, 1500);
            }
            
            initializeE8() {
                // Generate E8 root system (248 roots in 8D)
                // Using the standard construction
                const roots = [];
                
                // Type 1: All permutations of (±1,±1,0,0,0,0,0,0) with even number of minus signs
                for (let i = 0; i < 8; i++) {
                    for (let j = i + 1; j < 8; j++) {
                        for (let signs = 0; signs < 4; signs++) {
                            const root = new Array(8).fill(0);
                            root[i] = (signs & 1) ? 1 : -1;
                            root[j] = (signs & 2) ? 1 : -1;
                            if ((signs & 1) + ((signs & 2) >> 1) % 2 === 0) {
                                roots.push(root);
                            }
                        }
                    }
                }
                
                // Type 2: All permutations of (±1/2, ±1/2, ..., ±1/2) with even number of minus signs
                for (let config = 0; config < 128; config++) {
                    let minusCount = 0;
                    const root = [];
                    for (let i = 0; i < 8; i++) {
                        const sign = (config >> i) & 1 ? -1 : 1;
                        if (sign === -1) minusCount++;
                        root.push(sign * 0.5);
                    }
                    if (minusCount % 2 === 0) {
                        roots.push(root);
                    }
                }
                
                this.e8Roots = roots.slice(0, 248); // Ensure exactly 248 roots
            }
            
            initializeVisualization() {
                // Three.js setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000510, 0.001);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 50;
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('visualization-canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x0a0a0a);
                this.scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0x00ccff, 1, 100);
                pointLight.position.set(20, 20, 20);
                this.scene.add(pointLight);
                
                // Create particle system for E8 roots
                this.createE8Particles();
                
                // Handle resize
                window.addEventListener('resize', () => this.onResize());
            }
            
            createE8Particles() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.e8Roots.length * 3);
                const colors = new Float32Array(this.e8Roots.length * 3);
                const sizes = new Float32Array(this.e8Roots.length);
                
                // Project 8D roots to 3D and assign colors
                this.e8Roots.forEach((root, i) => {
                    // Simple projection: take first 3 dimensions
                    positions[i * 3] = root[0] * 20;
                    positions[i * 3 + 1] = root[1] * 20;
                    positions[i * 3 + 2] = root[2] * 20;
                    
                    // Color based on root properties
                    const magnitude = Math.sqrt(root.reduce((sum, x) => sum + x * x, 0));
                    const hue = (magnitude * 180 + 180) % 360;
                    const color = new THREE.Color();
                    color.setHSL(hue / 360, 0.8, 0.6);
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = 2 + magnitude;
                });
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
                
                // Add connection lines for nearby roots
                this.createE8Connections();
            }
            
            createE8Connections() {
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x0088ff,
                    opacity: 0.2,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const positions = this.particles.geometry.attributes.position.array;
                const connectionThreshold = 15; // Distance threshold for connections
                
                for (let i = 0; i < this.e8Roots.length; i++) {
                    for (let j = i + 1; j < this.e8Roots.length; j++) {
                        const dx = positions[i * 3] - positions[j * 3];
                        const dy = positions[i * 3 + 1] - positions[j * 3 + 1];
                        const dz = positions[i * 3 + 2] - positions[j * 3 + 2];
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (distance < connectionThreshold) {
                            const lineGeometry = new THREE.BufferGeometry();
                            const linePositions = new Float32Array([
                                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
                            ]);
                            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            this.scene.add(line);
                        }
                    }
                }
            }
            
            initializeControls() {
                // Slider controls
                const sliders = [
                    { id: 'rotation', param: 'rotation', min: 0, max: Math.PI * 2, display: 3 },
                    { id: 'dimension', param: 'dimension', min: 2, max: 8, display: 0 },
                    { id: 'bracket', param: 'bracketIntensity', min: 0, max: 1, display: 3 },
                    { id: 'chladni', param: 'chladniFreq', min: 20, max: 2000, display: 0 }
                ];
                
                sliders.forEach(slider => {
                    const element = document.getElementById(slider.id);
                    const valueDisplay = document.getElementById(slider.id + '-val');
                    const visual = element.nextElementSibling.nextElementSibling;
                    
                    element.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.params[slider.param] = value;
                        
                        // Update display
                        valueDisplay.textContent = slider.display > 0 ? 
                            value.toFixed(slider.display) : Math.floor(value);
                        
                        // Update visual bar
                        const percent = ((value - slider.min) / (slider.max - slider.min)) * 100;
                        visual.style.setProperty('--value', percent + '%');
                        
                        // Apply changes
                        if (slider.id === 'dimension') {
                            this.updateProjection();
                        }
                    });
                });
                
                // Mouse/touch controls for rotation
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', () => this.onMouseUp());
                
                canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
                canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
                canvas.addEventListener('touchend', () => this.onTouchEnd());
                
                // Make HUD panels draggable
                this.initializeDraggablePanels();
            }
            
            initializeDraggablePanels() {
                const panels = document.querySelectorAll('.hud-panel');
                
                panels.forEach(panel => {
                    const header = panel.querySelector('.hud-header');
                    let isDragging = false;
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    // Mouse support
                    header.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        offsetX = e.clientX - panel.offsetLeft;
                        offsetY = e.clientY - panel.offsetTop;
                        panel.style.cursor = 'grabbing';
                        panel.style.zIndex = '1000'; // Bring to front
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        e.preventDefault();
                        
                        let x = e.clientX - offsetX;
                        let y = e.clientY - offsetY;
                        
                        // Keep on screen
                        x = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, x));
                        y = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, y));
                        
                        panel.style.left = x + 'px';
                        panel.style.top = y + 'px';
                        panel.style.right = 'auto';
                        panel.style.bottom = 'auto';
                        panel.style.transform = 'none';
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            panel.style.cursor = '';
                            panel.style.zIndex = '100';
                        }
                    });
                    
                    // Touch support
                    header.addEventListener('touchstart', (e) => {
                        const touch = e.touches[0];
                        isDragging = true;
                        offsetX = touch.clientX - panel.offsetLeft;
                        offsetY = touch.clientY - panel.offsetTop;
                        panel.style.zIndex = '1000';
                        e.preventDefault();
                    });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        e.preventDefault();
                        
                        const touch = e.touches[0];
                        let x = touch.clientX - offsetX;
                        let y = touch.clientY - offsetY;
                        
                        // Keep on screen
                        x = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, x));
                        y = Math.max(0, Math.min(window.innerHeight - panel.offsetHeight, y));
                        
                        panel.style.left = x + 'px';
                        panel.style.top = y + 'px';
                        panel.style.right = 'auto';
                        panel.style.bottom = 'auto';
                        panel.style.transform = 'none';
                    });
                    
                    document.addEventListener('touchend', () => {
                        if (isDragging) {
                            isDragging = false;
                            panel.style.zIndex = '100';
                        }
                    });
                });
            }
            
            initializeConsciousness() {
                // Create consciousness grid cells
                const grid = document.getElementById('consciousness-grid');
                for (let i = 0; i < 64; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'consciousness-cell';
                    grid.appendChild(cell);
                }
                
                // Initialize consciousness field with quantum fluctuations
                for (let i = 0; i < 64; i++) {
                    this.consciousness[i] = Math.random() * 0.1;
                }
            }
            
            updateProjection() {
                // Re-project E8 roots based on selected dimensions
                const positions = this.particles.geometry.attributes.position.array;
                const dim = Math.floor(this.params.dimension);
                
                this.e8Roots.forEach((root, i) => {
                    if (dim <= 3) {
                        positions[i * 3] = root[0] * 20;
                        positions[i * 3 + 1] = root[1] * 20;
                        positions[i * 3 + 2] = dim === 3 ? root[2] * 20 : 0;
                    } else {
                        // Higher dimensional projection using stereographic projection
                        const r = Math.sqrt(root.slice(0, dim).reduce((sum, x) => sum + x * x, 0));
                        const theta = Math.atan2(root[1], root[0]);
                        const phi = r > 0 ? Math.acos(root[2] / r) : 0;
                        
                        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta) * 20;
                        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta) * 20;
                        positions[i * 3 + 2] = r * Math.cos(phi) * 20;
                    }
                });
                
                this.particles.geometry.attributes.position.needsUpdate = true;
            }
            
            updateConsciousness() {
                // Update consciousness field based on E8 geometry
                const cells = document.querySelectorAll('.consciousness-cell');
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < 64; i++) {
                    // Quantum fluctuations with E8 influence
                    const x = i % 8;
                    const y = Math.floor(i / 8);
                    const e8Influence = this.e8Roots[i % this.e8Roots.length];
                    
                    const wave = Math.sin(time + x * 0.5) * Math.cos(time * 0.7 + y * 0.3);
                    const quantum = Math.random() * 0.1 - 0.05;
                    const bracket = this.params.bracketIntensity * e8Influence[0];
                    
                    this.consciousness[i] = (this.consciousness[i] * 0.95) + 
                                          (wave * 0.03) + quantum + (bracket * 0.02);
                    
                    // Clamp to [0, 1]
                    this.consciousness[i] = Math.max(0, Math.min(1, this.consciousness[i]));
                    
                    // Update visual
                    const intensity = this.consciousness[i];
                    cells[i].style.setProperty('--intensity', intensity);
                    
                    const hue = 180 + intensity * 100;
                    cells[i].style.setProperty('--cell-color', 
                        `hsla(${hue}, 80%, ${30 + intensity * 40}%, ${0.3 + intensity * 0.7})`);
                }
                
                // Update metrics
                this.updateMetrics();
            }
            
            updateMetrics() {
                // Calculate mathematical metrics
                const sum = this.consciousness.reduce((a, b) => a + b, 0);
                const mean = sum / 64;
                const variance = this.consciousness.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / 64;
                
                // Update coherence (normalized variance)
                this.params.coherence = 1 - Math.min(1, variance * 10);
                document.getElementById('coherence-metric').textContent = 
                    this.params.coherence.toFixed(3);
                
                // Update entanglement (correlation measure)
                let correlation = 0;
                for (let i = 0; i < 63; i++) {
                    correlation += Math.abs(this.consciousness[i] - this.consciousness[i + 1]);
                }
                this.params.entanglement = 1 - (correlation / 63);
                document.getElementById('entanglement-metric').textContent = 
                    this.params.entanglement.toFixed(3);
                
                // Update stability (time derivative)
                const stability = 0.999 - variance * 0.1;
                document.getElementById('stability-metric').textContent = 
                    stability.toFixed(3);
                
                // Update mathematical readouts
                const ricci = -0.1337 + Math.sin(Date.now() * 0.0001) * 0.01;
                document.getElementById('ricci-val').textContent = ricci.toFixed(4);
                
                const gaussian = 0.0618 * (1 + Math.cos(Date.now() * 0.00013) * 0.1);
                document.getElementById('gaussian-val').textContent = gaussian.toFixed(4);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate E8 structure
                if (this.particles) {
                    this.particles.rotation.x += 0.001;
                    this.particles.rotation.y += 0.002;
                    
                    // Apply user rotation
                    this.particles.rotation.x += (this.targetRotationX - this.particles.rotation.x) * 0.05;
                    this.particles.rotation.y += (this.targetRotationY - this.particles.rotation.y) * 0.05;
                    
                    // Apply parameter rotation
                    this.particles.rotation.z = this.params.rotation;
                }
                
                // Update consciousness field
                if (Date.now() % 3 === 0) { // Throttle updates
                    this.updateConsciousness();
                }
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
            
            // Mouse/touch handlers
            onMouseDown(e) {
                this.isDragging = true;
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
            }
            
            onMouseMove(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.mouseX;
                const deltaY = e.clientY - this.mouseY;
                
                this.targetRotationY += deltaX * 0.01;
                this.targetRotationX += deltaY * 0.01;
                
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
            }
            
            onMouseUp() {
                this.isDragging = false;
            }
            
            onTouchStart(e) {
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.mouseX = e.touches[0].clientX;
                    this.mouseY = e.touches[0].clientY;
                }
            }
            
            onTouchMove(e) {
                if (!this.isDragging || e.touches.length !== 1) return;
                
                const deltaX = e.touches[0].clientX - this.mouseX;
                const deltaY = e.touches[0].clientY - this.mouseY;
                
                this.targetRotationY += deltaX * 0.01;
                this.targetRotationX += deltaY * 0.01;
                
                this.mouseX = e.touches[0].clientX;
                this.mouseY = e.touches[0].clientY;
            }
            
            onTouchEnd() {
                this.isDragging = false;
            }
            
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Global functions for UI
        function minimizePanel(id) {
            document.getElementById(id).classList.toggle('minimized');
        }
        
        function closePanel(id) {
            const panel = document.getElementById(id);
            panel.style.opacity = '0';
            setTimeout(() => {
                panel.style.display = 'none';
            }, 300);
        }
        
        function setMode(mode) {
            // Update mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update consciousness state
            const modes = {
                'discrete': 'forest',
                'continuous': 'ocean', 
                'temporal': 'aurora',
                'void': 'nebula',
                'e8': 'aurora'
            };
            
            document.body.setAttribute('data-consciousness', modes[mode]);
            
            // Update precision indicator
            const precision = document.getElementById('precision');
            if (mode === 'e8') {
                precision.classList.add('active');
            } else {
                precision.classList.remove('active');
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.keats = new TranscendentKEATS();
            });
        } else {
            window.keats = new TranscendentKEATS();
        }
    </script>
</body>
</html>