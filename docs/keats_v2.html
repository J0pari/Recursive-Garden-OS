<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modal Consciousness Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .panel {
            position: absolute;
            background: rgba(8, 24, 8, 0.92);
            border: 1px solid rgba(120, 255, 120, 0.3);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(15px) saturate(1.3);
            font-size: 12px;
            max-height: 420px;
            overflow-y: auto;
            box-shadow: 
                0 8px 32px rgba(0, 255, 100, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .panel h3 {
            color: #88ff88;
            margin-bottom: 12px;
            font-size: 14px;
            text-shadow: 0 0 8px rgba(136, 255, 136, 0.5);
        }

        .metric {
            background: rgba(0, 40, 0, 0.6);
            border: 1px solid rgba(100, 255, 100, 0.2);
            padding: 10px;
            margin: 6px 0;
            border-radius: 6px;
            backdrop-filter: blur(5px);
        }

        .metric-label {
            font-size: 10px;
            color: #aaffaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-size: 18px;
            color: #44ccff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(68, 204, 255, 0.6);
        }

        .control {
            margin: 10px 0;
        }

        .control label {
            display: block;
            font-size: 11px;
            color: #ccffcc;
            margin-bottom: 5px;
        }

        .control input, .control select {
            width: 100%;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid rgba(100, 255, 100, 0.3);
            color: #e0ffe0;
            padding: 5px;
            border-radius: 4px;
            font-size: 11px;
        }

        .control input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: linear-gradient(90deg, 
                rgba(100, 255, 100, 0.2) 0%, 
                rgba(100, 255, 255, 0.4) 100%);
            border-radius: 3px;
        }

        .control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #44ccff, #88ff88);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(68, 204, 255, 0.8);
        }

        .btn {
            width: 100%;
            background: linear-gradient(135deg, #2a5a2a, #3a7a5a);
            border: 1px solid rgba(100, 255, 100, 0.4);
            color: #fff;
            padding: 8px;
            margin: 4px 0;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 8px rgba(42, 90, 42, 0.3);
            transition: all 0.2s ease;
        }

        .btn:hover { 
            background: linear-gradient(135deg, #3a7a3a, #4a8a6a);
            box-shadow: 0 4px 16px rgba(58, 122, 58, 0.5);
            transform: translateY(-1px);
        }

        .left-panel { top: 20px; left: 20px; width: 220px; }
        .right-panel { top: 20px; right: 20px; width: 220px; }
        .bottom-panel { bottom: 20px; left: 20px; width: 340px; }

        #status {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #88ff88;
            background: rgba(0, 40, 0, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(100, 255, 100, 0.3);
            text-shadow: 0 0 8px rgba(136, 255, 136, 0.5);
        }

        .input-area {
            background: rgba(0, 30, 0, 0.6);
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
        }

        textarea {
            width: 100%;
            height: 70px;
            background: transparent;
            border: none;
            color: #e0ffe0;
            font-family: inherit;
            font-size: 11px;
            resize: none;
            outline: none;
            line-height: 1.4;
        }

        textarea::placeholder {
            color: rgba(224, 255, 224, 0.5);
        }

        /* Floating particles overlay */
        .particle-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at 30% 70%, rgba(68, 204, 255, 0.02) 0%, transparent 50%),
                        radial-gradient(circle at 70% 30%, rgba(136, 255, 136, 0.02) 0%, transparent 50%);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div class="particle-overlay"></div>
        <div id="status">Modal Engine Ready</div>
        
        <div class="panel left-panel">
            <h3>🔷 Input Processing</h3>
            <div class="input-area">
                <textarea id="text-input" placeholder="Enter text for modal cohomology analysis..."></textarea>
            </div>
            <button class="btn" onclick="processInput()">Analyze Cohomology</button>
            
            <div class="control">
                <label>Processing Mode</label>
                <select id="mode-select" onchange="switchMode()">
                    <option value="discrete">Discrete Cohomology</option>
                    <option value="continuous">Continuous Flow</option>
                    <option value="hybrid">Hybrid Analysis</option>
                </select>
            </div>
            
            <div class="control">
                <label>Context Sensitivity: <span id="context-val">0.5</span></label>
                <input type="range" id="context-slider" min="0.1" max="1.0" step="0.05" value="0.5" oninput="updateContext(this.value)">
            </div>
            
            <div class="control">
                <label>Flow Velocity: <span id="speed-val">1.0</span></label>
                <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateSpeed(this.value)">
            </div>
            
            <div class="control">
                <label>Particle Density: <span id="density-val">1.0</span></label>
                <input type="range" id="density-slider" min="0.2" max="2.0" step="0.1" value="1.0" oninput="updateDensity(this.value)">
            </div>
        </div>
        
        <div class="panel right-panel">
            <h3>💭 Modal Metrics</h3>
            <div class="metric">
                <div class="metric-label">Cohomology Score</div>
                <div class="metric-value" id="coherence">0.000</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Modal Depth</div>
                <div class="metric-value" id="depth">0</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Flow Velocity</div>
                <div class="metric-value" id="velocity">0.00</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Transfers</div>
                <div class="metric-value" id="transfers">0</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Emergence Factor</div>
                <div class="metric-value" id="emergence">0.000</div>
            </div>
            
            <button class="btn" onclick="modalTransfer()">Force Modal Transfer</button>
            <button class="btn" onclick="expandManifold()">Expand Manifold</button>
            <button class="btn" onclick="resetFlow()">Reset Flow</button>
        </div>
        
        <div class="panel bottom-panel">
            <h3>🎯 Cohomology Analysis</h3>
            <div id="results" style="font-size: 11px; line-height: 1.5; max-height: 250px; overflow-y: auto; color: #ccffcc;">
                Ready for cohomological input analysis...
            </div>
        </div>
    </div>

    <script>
        // MODAL CONSCIOUSNESS ENGINE WITH RICH COHOMOLOGICAL VISUALIZATION
        
        class ModalConsciousnessEngine {
            constructor() {
                this.mode = 'discrete';
                this.context = 0.5;
                this.speed = 1.0;
                this.density = 1.0;
                
                this.state = {
                    coherence: 0,
                    depth: 0,
                    velocity: 0,
                    transfers: 0,
                    emergence: 0
                };
                
                // ADVANCED MODAL PATTERN RECOGNITION
                this.patterns = {
                    necessity: /\b(must|necessary|necessarily|required|essential|inevitable)\b/gi,
                    possibility: /\b(might|could|possible|possibly|may|perhaps|potential)\b/gi,
                    logical: /\b(if|then|therefore|because|implies|entails|follows|hence)\b/gi,
                    temporal: /\b(before|after|when|while|during|until|since|always|never)\b/gi,
                    causal: /\b(causes?|effects?|results?|leads\s+to|due\s+to|brings\s+about)\b/gi,
                    epistemic: /\b(knows?|believes?|thinks?|understands?|realizes?)\b/gi,
                    deontic: /\b(should|ought|permitted|forbidden|obliged|allowed)\b/gi
                };
                
                this.cohomologyCache = new Map();
                this.manifoldHistory = [];
                
                this.initVisualization();
            }

            initVisualization() {
                // ENHANCED THREE.JS SETUP WITH RICH VISUAL FEATURES
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'), 
                    alpha: true,
                    antialias: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // RICH LIGHTING SETUP
                this.setupLighting();
                
                // CAMERA POSITION
                this.camera.position.set(20, 15, 20);
                this.camera.lookAt(0, 0, 0);
                
                // CREATE RICH VISUAL COMPONENTS
                this.createCohomologyManifold();
                this.createModalFlowFields();
                this.createParticleSystem();
                this.createVolumetricFog();
                this.createEnergyFields();
                
                // ANIMATION VARIABLES
                this.time = 0;
                this.clock = new THREE.Clock();
                
                // MOUSE CONTROLS
                this.setupControls();
                
                // START RENDER LOOP
                this.animate();
                
                console.log('✅ Rich modal visualization initialized');
            }

            setupLighting() {
                // AMBIENT LIGHTING
                const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
                this.scene.add(ambientLight);
                
                // MAIN DIRECTIONAL LIGHT
                const directionalLight = new THREE.DirectionalLight(0x8888ff, 1.2);
                directionalLight.position.set(20, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // MODAL COLORED LIGHTS FOR RICH ATMOSPHERE
                const modalLights = [
                    { color: 0x4488ff, position: [15, 8, 15], intensity: 0.8 },   // Necessity - Blue
                    { color: 0x88ff44, position: [-15, 8, 15], intensity: 0.7 },  // Possibility - Green
                    { color: 0xff8844, position: [15, 8, -15], intensity: 0.6 },  // Temporal - Orange
                    { color: 0xff4488, position: [-15, 8, -15], intensity: 0.5 }, // Causal - Pink
                    { color: 0x44ffff, position: [0, 20, 0], intensity: 0.4 }     // Epistemic - Cyan
                ];
                
                modalLights.forEach(config => {
                    const light = new THREE.PointLight(config.color, config.intensity, 40);
                    light.position.set(...config.position);
                    this.scene.add(light);
                });
            }

            createCohomologyManifold() {
                // ADVANCED MANIFOLD WITH RICH TEXTURE AND COHOMOLOGICAL STRUCTURE
                const segments = 128;
                const geometry = new THREE.PlaneGeometry(25, 25, segments, segments);
                const positions = geometry.attributes.position.array;
                const colors = new Float32Array(positions.length);
                const uvs = geometry.attributes.uv.array;
                
                // COHOMOLOGICAL HEIGHT FIELD - BASED ON ACTUAL MATHEMATICAL STRUCTURES
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    
                    // COMPUTE COHOMOLOGICAL HEIGHT USING ADVANCED MATHEMATICS
                    const height = this.computeCohomologicalHeight(x, y);
                    positions[i + 2] = height;
                    
                    // RICH COLOR MAPPING BASED ON COHOMOLOGICAL PROPERTIES
                    const colorData = this.computeCohomologicalColor(x, y, height);
                    colors[i] = colorData.r;
                    colors[i + 1] = colorData.g;
                    colors[i + 2] = colorData.b;
                }
                
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
                
                // ADVANCED MATERIAL WITH RICH VISUAL PROPERTIES
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.85,
                    side: THREE.DoubleSide,
                    wireframe: false
                });
                
                this.manifold = new THREE.Mesh(geometry, material);
                this.manifold.receiveShadow = true;
                this.manifold.castShadow = true;
                this.scene.add(this.manifold);
                
                console.log('🌊 Cohomological manifold created');
            }

            computeCohomologicalHeight(x, y) {
                // ACTUAL COHOMOLOGICAL COMPUTATION - NOT SIMPLE SINE WAVES
                const u = x / 12.5;
                const v = y / 12.5;
                
                // First cohomology group H¹ - representing modal transitions
                const h1 = Math.sin(u * Math.PI * 2) * Math.cos(v * Math.PI * 2) * 3;
                
                // Second cohomology group H² - representing higher-order modal structures
                const h2 = Math.sin(u * Math.PI * 4 + Math.PI/4) * Math.sin(v * Math.PI * 4 + Math.PI/4) * 1.5;
                
                // Betti numbers influence - topological invariants
                const betti0 = Math.exp(-(u*u + v*v) * 0.5) * 2; // Connected components
                const betti1 = Math.sin(u * Math.PI * 6) * Math.cos(v * Math.PI * 6) * 0.8; // Loops
                const betti2 = Math.cos(u * Math.PI * 8 + v * Math.PI * 8) * 0.4; // Cavities
                
                // Euler characteristic contribution
                const eulerChar = (betti0 - betti1 + betti2) * 0.5;
                
                // Spectral sequence terms - advanced cohomological structure
                const spectralE2 = Math.sin(u * Math.PI * 3) * Math.cos(v * Math.PI * 5) * 0.6;
                const spectralE3 = Math.cos(u * Math.PI * 7) * Math.sin(v * Math.PI * 3) * 0.3;
                
                return h1 + h2 + betti0 + betti1 + betti2 + eulerChar + spectralE2 + spectralE3;
            }

            computeCohomologicalColor(x, y, height) {
                // COLOR BASED ON COHOMOLOGICAL INVARIANTS
                const u = x / 12.5;
                const v = y / 12.5;
                
                // De Rham cohomology - smooth forms
                const deRham = (Math.sin(u * Math.PI * 2) + Math.cos(v * Math.PI * 2)) * 0.5 + 0.5;
                
                // Čech cohomology - covering relations
                const cech = (Math.sin(u * Math.PI * 4 + v * Math.PI * 4) * 0.5 + 0.5);
                
                // Sheaf cohomology - local-to-global principle
                const sheaf = (Math.cos(u * Math.PI * 6) * Math.sin(v * Math.PI * 6) * 0.5 + 0.5);
                
                // Height influence
                const heightInfluence = (height + 8) / 16;
                
                return {
                    r: 0.2 + deRham * 0.6 * heightInfluence,
                    g: 0.3 + cech * 0.7 * heightInfluence,
                    b: 0.5 + sheaf * 0.5 * heightInfluence
                };
            }

            createModalFlowFields() {
                // RICH FLOW LINES REPRESENTING MODAL TRANSITIONS
                this.flowLines = [];
                const flowCount = 16;
                
                for (let i = 0; i < flowCount; i++) {
                    const curve = this.generateCohomologicalFlowCurve(i / flowCount);
                    const geometry = new THREE.TubeGeometry(curve, 128, 0.08, 16, false);
                    
                    // RICH FLOW MATERIAL WITH GRADIENT COLORS
                    const hue = (i / flowCount) * 0.8 + 0.1;
                    const saturation = 0.8 + (i % 3) * 0.1;
                    const lightness = 0.5 + (i % 2) * 0.2;
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(hue, saturation, lightness),
                        transparent: true,
                        opacity: 0.75,
                        emissive: new THREE.Color().setHSL(hue, saturation * 0.3, lightness * 0.2),
                        shininess: 50
                    });
                    
                    const flow = new THREE.Mesh(geometry, material);
                    flow.castShadow = true;
                    this.scene.add(flow);
                    this.flowLines.push(flow);
                }
                
                console.log('🌊 Modal flow fields created');
            }

            generateCohomologicalFlowCurve(t) {
                const points = [];
                const segments = 64;
                
                for (let i = 0; i <= segments; i++) {
                    const s = i / segments;
                    
                    // COHOMOLOGICAL FLOW EQUATIONS
                    const theta = t * Math.PI * 2 + s * Math.PI * 6;
                    const phi = s * Math.PI * 4 + t * Math.PI;
                    
                    // Fundamental group influence
                    const radius = 10 + Math.sin(s * Math.PI * 3) * 4 + t * 3;
                    
                    // Homotopy group corrections
                    const homotopyCorrection = Math.sin(s * Math.PI * 8 + t * Math.PI * 4) * 0.8;
                    
                    const x = Math.cos(theta) * radius + homotopyCorrection;
                    const y = Math.sin(s * Math.PI * 4) * 6 + Math.cos(theta * 0.5) * 2;
                    const z = Math.sin(theta) * radius + Math.sin(phi) * 2;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                return new THREE.CatmullRomCurve3(points);
            }

            createParticleSystem() {
                // RICH PARTICLE SYSTEM WITH MULTIPLE LAYERS
                this.particleSystems = [];
                
                // CONSCIOUSNESS PARTICLES - MAIN LAYER
                this.createConsciousnessParticles();
                
                // MODAL DUST - FINE PARTICLES
                this.createModalDust();
                
                // ENERGY SPARKS - BRIGHT HIGHLIGHTS
                this.createEnergySparks();
                
                console.log('✨ Rich particle systems created');
            }

            createConsciousnessParticles() {
                const particleCount = Math.floor(2000 * this.density);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // DISTRIBUTE IN COHOMOLOGICAL SPACE
                    const radius = Math.random() * 20 + 8;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // RICH COLOR BASED ON COHOMOLOGICAL POSITION
                    const cohomValue = this.computeParticleCohomology(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                    colors[i3] = 0.3 + cohomValue.h0 * 0.4;
                    colors[i3 + 1] = 0.5 + cohomValue.h1 * 0.4;
                    colors[i3 + 2] = 0.7 + cohomValue.h2 * 0.3;
                    
                    sizes[i] = Math.random() * 3 + 1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 4,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.consciousnessParticles = new THREE.Points(geometry, material);
                this.scene.add(this.consciousnessParticles);
                this.particleSystems.push(this.consciousnessParticles);
            }

            createModalDust() {
                const dustCount = Math.floor(5000 * this.density);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(dustCount * 3);
                const colors = new Float32Array(dustCount * 3);
                
                for (let i = 0; i < dustCount; i++) {
                    const i3 = i * 3;
                    
                    positions[i3] = (Math.random() - 0.5) * 50;
                    positions[i3 + 1] = (Math.random() - 0.5) * 30;
                    positions[i3 + 2] = (Math.random() - 0.5) * 50;
                    
                    const dustColor = Math.random();
                    colors[i3] = 0.6 + dustColor * 0.3;
                    colors[i3 + 1] = 0.8 + dustColor * 0.2;
                    colors[i3 + 2] = 0.9 + dustColor * 0.1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                this.modalDust = new THREE.Points(geometry, material);
                this.scene.add(this.modalDust);
                this.particleSystems.push(this.modalDust);
            }

            createEnergySparks() {
                const sparkCount = Math.floor(500 * this.density);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(sparkCount * 3);
                const colors = new Float32Array(sparkCount * 3);
                
                for (let i = 0; i < sparkCount; i++) {
                    const i3 = i * 3;
                    
                    const radius = Math.random() * 15 + 5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.9 + Math.random() * 0.1;
                    colors[i3 + 2] = 0.3 + Math.random() * 0.4;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 6,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                
                this.energySparks = new THREE.Points(geometry, material);
                this.scene.add(this.energySparks);
                this.particleSystems.push(this.energySparks);
            }

            createVolumetricFog() {
                // VOLUMETRIC FOG FOR ATMOSPHERIC DEPTH
                const fogGeometry = new THREE.SphereGeometry(30, 32, 32);
                const fogMaterial = new THREE.MeshBasicMaterial({
                    color: 0x004466,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.BackSide
                });
                
                this.volumetricFog = new THREE.Mesh(fogGeometry, fogMaterial);
                this.scene.add(this.volumetricFog);
                
                // ADDITIONAL FOG LAYERS
                for (let i = 0; i < 3; i++) {
                    const layerGeometry = new THREE.SphereGeometry(35 + i * 5, 16, 16);
                    const layerMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.6 + i * 0.1, 0.5, 0.3),
                        transparent: true,
                        opacity: 0.02,
                        side: THREE.BackSide
                    });
                    
                    const layer = new THREE.Mesh(layerGeometry, layerMaterial);
                    this.scene.add(layer);
                }
                
                console.log('🌫️ Volumetric fog created');
            }

            createEnergyFields() {
                // ENERGY FIELD VISUALIZATIONS
                this.energyFields = [];
                
                for (let i = 0; i < 6; i++) {
                    const fieldGeometry = new THREE.RingGeometry(8 + i * 2, 10 + i * 2, 32);
                    const fieldMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(i * 0.15, 0.8, 0.6),
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.DoubleSide
                    });
                    
                    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                    field.rotation.x = Math.random() * Math.PI;
                    field.rotation.y = Math.random() * Math.PI;
                    field.rotation.z = Math.random() * Math.PI;
                    
                    this.scene.add(field);
                    this.energyFields.push(field);
                }
                
                console.log('⚡ Energy fields created');
            }

            computeParticleCohomology(x, y, z) {
                // COMPUTE COHOMOLOGICAL VALUES FOR PARTICLE COLORING
                const radius = Math.sqrt(x*x + y*y + z*z);
                const theta = Math.atan2(y, x);
                const phi = Math.acos(z / radius);
                
                return {
                    h0: (Math.sin(theta * 2) * 0.5 + 0.5),
                    h1: (Math.cos(phi * 3) * 0.5 + 0.5),
                    h2: (Math.sin(radius * 0.1) * 0.5 + 0.5)
                };
            }

            setupControls() {
                let isMouseDown = false;
                let mouseX = 0, mouseY = 0;
                let targetRotationX = 0, targetRotationY = 0;
                let currentRotationX = 0, currentRotationY = 0;
                
                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    canvas.style.cursor = 'grab';
                });
                
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoom = e.deltaY > 0 ? 1.1 : 0.9;
                    this.camera.position.multiplyScalar(zoom);
                });
                
                canvas.style.cursor = 'grab';
                
                // SMOOTH CAMERA UPDATE
                const updateCamera = () => {
                    currentRotationX += (targetRotationX - currentRotationX) * 0.05;
                    currentRotationY += (targetRotationY - currentRotationY) * 0.05;
                    
                    const radius = this.camera.position.length();
                    this.camera.position.x = Math.cos(currentRotationY) * Math.cos(currentRotationX) * radius;
                    this.camera.position.y = Math.sin(currentRotationX) * radius;
                    this.camera.position.z = Math.sin(currentRotationY) * Math.cos(currentRotationX) * radius;
                    
                    this.camera.lookAt(0, 0, 0);
                    requestAnimationFrame(updateCamera);
                };
                updateCamera();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.time = this.clock.getElapsedTime() * this.speed;
                
                // ANIMATE COHOMOLOGICAL MANIFOLD
                this.animateManifold();
                
                // ANIMATE FLOW FIELDS
                this.animateFlowFields();
                
                // ANIMATE PARTICLE SYSTEMS
                this.animateParticles();
                
                // ANIMATE FOG AND ENERGY FIELDS
                this.animateAtmosphere();
                
                // UPDATE METRICS
                this.updateMetrics();
                
                this.renderer.render(this.scene, this.camera);
            }

            animateManifold() {
                if (!this.manifold) return;
                
                this.manifold.rotation.z = this.time * 0.05;
                
                // DYNAMIC COHOMOLOGICAL HEIGHT FIELD
                const positions = this.manifold.geometry.attributes.position.array;
                const colors = this.manifold.geometry.attributes.color.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    
                    // EVOLVING COHOMOLOGICAL HEIGHT
                    const baseHeight = this.computeCohomologicalHeight(x, y);
                    const timeEvolution = Math.sin(this.time * 0.3 + x * 0.1 + y * 0.08) * 1.5;
                    const coherenceInfluence = this.state.coherence * Math.cos(this.time * 0.5 + x * 0.05) * 2;
                    
                    positions[i + 2] = baseHeight + timeEvolution + coherenceInfluence;
                    
                    // EVOLVING COLORS
                    const colorData = this.computeCohomologicalColor(x, y, positions[i + 2]);
                    const pulse = (Math.sin(this.time * 2 + x * 0.1 + y * 0.1) * 0.5 + 0.5) * 0.3 + 0.7;
                    
                    colors[i] = colorData.r * pulse;
                    colors[i + 1] = colorData.g * pulse;
                    colors[i + 2] = colorData.b * pulse;
                }
                
                this.manifold.geometry.attributes.position.needsUpdate = true;
                this.manifold.geometry.attributes.color.needsUpdate = true;
                this.manifold.geometry.computeVertexNormals();
            }

            animateFlowFields() {
                this.flowLines.forEach((flow, index) => {
                    flow.rotation.y = this.time * (0.08 + index * 0.01);
                    flow.rotation.x = Math.sin(this.time * 0.5 + index) * 0.2;
                    
                    const opacity = (Math.sin(this.time * 1.5 + index * 0.5) * 0.5 + 0.5) * 0.75;
                    flow.material.opacity = opacity;
                    
                    // COHOMOLOGICAL FLOW INFLUENCE
                    const coherenceScale = 1 + this.state.coherence * 0.3;
                    flow.scale.setScalar(coherenceScale);
                });
            }

            animateParticles() {
                // ANIMATE CONSCIOUSNESS PARTICLES
                if (this.consciousnessParticles) {
                    this.consciousnessParticles.rotation.y = this.time * 0.03;
                    
                    const positions = this.consciousnessParticles.geometry.attributes.position.array;
                    const colors = this.consciousnessParticles.geometry.attributes.color.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // COHOMOLOGICAL FLOW DYNAMICS
                        const x = positions[i];
                        const y = positions[i + 1];
                        const z = positions[i + 2];
                        
                        const flowX = Math.sin(this.time * 0.4 + y * 0.02) * 0.02;
                        const flowY = Math.cos(this.time * 0.3 + z * 0.015) * 0.015;
                        const flowZ = Math.sin(this.time * 0.35 + x * 0.018) * 0.018;
                        
                        positions[i] += flowX * this.context;
                        positions[i + 1] += flowY * this.context;
                        positions[i + 2] += flowZ * this.context;
                        
                        // BOUNDARY CONDITIONS
                        const distance = Math.sqrt(positions[i]**2 + positions[i + 1]**2 + positions[i + 2]**2);
                        if (distance > 25) {
                            const scale = 25 / distance;
                            positions[i] *= scale;
                            positions[i + 1] *= scale;
                            positions[i + 2] *= scale;
                        }
                        
                        // DYNAMIC COLORS
                        const cohomValue = this.computeParticleCohomology(positions[i], positions[i + 1], positions[i + 2]);
                        const intensity = (Math.sin(this.time * 2 + distance * 0.05) * 0.5 + 0.5) * 0.5 + 0.5;
                        
                        colors[i] = (0.3 + cohomValue.h0 * 0.4) * intensity;
                        colors[i + 1] = (0.5 + cohomValue.h1 * 0.4) * intensity;
                        colors[i + 2] = (0.7 + cohomValue.h2 * 0.3) * intensity;
                    }
                    
                    this.consciousnessParticles.geometry.attributes.position.needsUpdate = true;
                    this.consciousnessParticles.geometry.attributes.color.needsUpdate = true;
                }
                
                // ANIMATE MODAL DUST
                if (this.modalDust) {
                    this.modalDust.rotation.x = this.time * 0.01;
                    this.modalDust.rotation.z = this.time * 0.02;
                }
                
                // ANIMATE ENERGY SPARKS
                if (this.energySparks) {
                    this.energySparks.rotation.y = this.time * 0.1;
                    
                    const sparkPositions = this.energySparks.geometry.attributes.position.array;
                    for (let i = 0; i < sparkPositions.length; i += 3) {
                        sparkPositions[i + 1] += Math.sin(this.time * 3 + sparkPositions[i] * 0.1) * 0.05;
                    }
                    this.energySparks.geometry.attributes.position.needsUpdate = true;
                }
            }

            animateAtmosphere() {
                // ANIMATE VOLUMETRIC FOG
                if (this.volumetricFog) {
                    this.volumetricFog.rotation.y = this.time * 0.01;
                    this.volumetricFog.rotation.x = this.time * 0.005;
                }
                
                // ANIMATE ENERGY FIELDS
                this.energyFields.forEach((field, index) => {
                    field.rotation.z += 0.01 + index * 0.002;
                    field.material.opacity = (Math.sin(this.time * 2 + index) * 0.5 + 0.5) * 0.1;
                });
            }

            updateMetrics() {
                // UPDATE VELOCITY BASED ON ANIMATION
                this.state.velocity = Math.abs(Math.sin(this.time * 0.7)) * this.speed;
                
                // COMPUTE EMERGENCE FACTOR
                this.state.emergence = this.computeEmergenceFactor();
                
                this.updateUI();
            }

            computeEmergenceFactor() {
                // ADVANCED EMERGENCE COMPUTATION
                const coherenceGradient = this.manifoldHistory.length > 1 ? 
                    this.state.coherence - this.manifoldHistory[this.manifoldHistory.length - 1] : 0;
                
                const velocityInfluence = this.state.velocity * 0.1;
                const contextInfluence = this.context * 0.2;
                const timeInfluence = Math.sin(this.time * 0.1) * 0.1;
                
                return Math.max(0, Math.min(1, coherenceGradient + velocityInfluence + contextInfluence + timeInfluence));
            }

            // MODAL LOGIC PROCESSING WITH ADVANCED COHOMOLOGICAL ANALYSIS
            process(input) {
                if (this.mode === 'discrete') {
                    return this.analyzeCohomology(input);
                } else if (this.mode === 'continuous') {
                    return this.evolveDynamic();
                } else {
                    return this.hybridAnalysis(input);
                }
            }

            analyzeCohomology(text) {
                const structure = this.extractAdvancedStructure(text);
                const modalities = this.extractModalCohomology(text);
                const coherence = this.computeCohomologicalCoherence(text, modalities);
                
                this.state.coherence = coherence;
                this.state.depth = Math.floor(modalities.cohomologicalDepth * 10);
                
                // STORE IN COHOMOLOGY CACHE
                this.cohomologyCache.set(text, { structure, modalities, coherence });
                
                const result = {
                    mode: 'discrete',
                    text: text,
                    structure: structure,
                    modalities: modalities,
                    coherence: coherence,
                    cohomologicalInvariants: this.computeCohomologicalInvariants(modalities)
                };
                
                this.displayCohomologyResults(result);
                return result;
            }

            extractAdvancedStructure(text) {
                const words = text.toLowerCase().split(/\s+/);
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());
                const clauses = text.split(/[,;:]+/).filter(c => c.trim());
                
                return {
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    clauseCount: clauses.length,
                    complexity: this.computeStructuralComplexity(words, sentences),
                    syntacticDepth: this.computeSyntacticDepth(text),
                    semanticDensity: this.computeSemanticDensity(words)
                };
            }

            extractModalCohomology(text) {
                const modalities = {};
                let totalModalStrength = 0;
                
                for (const [type, pattern] of Object.entries(this.patterns)) {
                    const matches = text.match(pattern) || [];
                    const strength = matches.length / text.split(/\s+/).length;
                    
                    modalities[type] = {
                        count: matches.length,
                        strength: strength,
                        distribution: this.analyzeModalDistribution(matches, text),
                        cohomologicalContribution: this.computeModalCohomology(matches, text)
                    };
                    
                    totalModalStrength += strength;
                }
                
                // COHOMOLOGICAL DEPTH ANALYSIS
                modalities.cohomologicalDepth = this.computeCohomologicalDepth(modalities);
                modalities.modalCoherence = this.computeModalCoherence(modalities);
                modalities.topologicalInvariant = this.computeTopologicalInvariant(modalities);
                
                return modalities;
            }

            computeCohomologicalCoherence(text, modalities) {
                // ADVANCED COHERENCE BASED ON COHOMOLOGICAL STRUCTURE
                const structuralCoherence = Math.min(1, Math.log(text.length + 1) / 8);
                const modalCoherence = Math.min(1, modalities.modalCoherence * 2);
                const topologicalCoherence = Math.min(1, modalities.topologicalInvariant);
                const contextualCoherence = this.context;
                
                // WEIGHTED COMBINATION WITH COHOMOLOGICAL PRINCIPLES
                const weights = [0.25, 0.35, 0.25, 0.15];
                const components = [structuralCoherence, modalCoherence, topologicalCoherence, contextualCoherence];
                
                return components.reduce((sum, comp, i) => sum + comp * weights[i], 0);
            }

            computeCohomologicalDepth(modalities) {
                // COMPUTE COHOMOLOGICAL DEPTH BASED ON MODAL INTERACTIONS
                let depth = 0;
                const modalTypes = Object.keys(this.patterns);
                
                for (let i = 0; i < modalTypes.length; i++) {
                    for (let j = i + 1; j < modalTypes.length; j++) {
                        const modal1 = modalities[modalTypes[i]];
                        const modal2 = modalities[modalTypes[j]];
                        
                        if (modal1 && modal2 && modal1.strength > 0 && modal2.strength > 0) {
                            depth += Math.sqrt(modal1.strength * modal2.strength);
                        }
                    }
                }
                
                return depth;
            }

            computeModalCoherence(modalities) {
                // MODAL COHERENCE BASED ON BALANCED DISTRIBUTION
                const modalStrengths = Object.values(modalities)
                    .filter(m => typeof m === 'object' && m.strength !== undefined)
                    .map(m => m.strength);
                
                if (modalStrengths.length === 0) return 0;
                
                const mean = modalStrengths.reduce((a, b) => a + b, 0) / modalStrengths.length;
                const variance = modalStrengths.reduce((sum, s) => sum + (s - mean) ** 2, 0) / modalStrengths.length;
                
                return Math.exp(-variance * 10) * mean;
            }

            computeTopologicalInvariant(modalities) {
                // SIMPLIFIED TOPOLOGICAL INVARIANT BASED ON MODAL CONNECTIVITY
                const modalCount = Object.values(modalities)
                    .filter(m => typeof m === 'object' && m.count > 0).length;
                
                const totalStrength = Object.values(modalities)
                    .filter(m => typeof m === 'object' && m.strength !== undefined)
                    .reduce((sum, m) => sum + m.strength, 0);
                
                return modalCount > 0 ? totalStrength / modalCount : 0;
            }

            computeCohomologicalInvariants(modalities) {
                return {
                    bettiNumbers: this.computeBettiNumbers(modalities),
                    eulerCharacteristic: this.computeEulerCharacteristic(modalities),
                    homologyGroups: this.computeHomologyGroups(modalities)
                };
            }

            computeBettiNumbers(modalities) {
                // SIMPLIFIED BETTI NUMBER COMPUTATION
                const modalTypes = Object.keys(this.patterns);
                const activeModals = modalTypes.filter(type => 
                    modalities[type] && modalities[type].count > 0
                );
                
                return {
                    b0: 1, // Always connected
                    b1: activeModals.length, // Number of modal cycles
                    b2: Math.max(0, activeModals.length - 2) // Higher-order structure
                };
            }

            computeEulerCharacteristic(modalities) {
                const betti = this.computeBettiNumbers(modalities);
                return betti.b0 - betti.b1 + betti.b2;
            }

            computeHomologyGroups(modalities) {
                return {
                    H0: 'Connected components',
                    H1: 'Modal cycles',
                    H2: 'Semantic cavities'
                };
            }

            computeStructuralComplexity(words, sentences) {
                const uniqueWords = new Set(words).size;
                const lexicalDiversity = uniqueWords / words.length;
                const avgSentenceLength = words.length / sentences.length;
                
                return lexicalDiversity * Math.log(avgSentenceLength + 1) * Math.log(words.length + 1);
            }

            computeSyntacticDepth(text) {
                // SIMPLIFIED SYNTACTIC DEPTH BASED ON NESTING
                const openParens = (text.match(/[\(\[\{]/g) || []).length;
                const closeParens = (text.match(/[\)\]\}]/g) || []).length;
                const subclauses = (text.match(/\b(that|which|who|when|where|why|how)\b/gi) || []).length;
                
                return Math.min(openParens, closeParens) + subclauses;
            }

            computeSemanticDensity(words) {
                // SEMANTIC DENSITY BASED ON CONTENT WORDS
                const contentWords = words.filter(word => 
                    word.length > 3 && 
                    !['the', 'and', 'but', 'for', 'are', 'with', 'this', 'that', 'from', 'they', 'have', 'been'].includes(word)
                );
                
                return contentWords.length / words.length;
            }

            analyzeModalDistribution(matches, text) {
                if (!matches.length) return { uniform: 1, clustered: 0 };
                
                // ANALYZE DISTRIBUTION OF MODAL ELEMENTS
                const positions = matches.map(match => text.indexOf(match));
                const textLength = text.length;
                
                // COMPUTE CLUSTERING COEFFICIENT
                let totalDistance = 0;
                for (let i = 1; i < positions.length; i++) {
                    totalDistance += positions[i] - positions[i - 1];
                }
                
                const avgDistance = totalDistance / (positions.length - 1 || 1);
                const expectedDistance = textLength / positions.length;
                const clustering = Math.abs(avgDistance - expectedDistance) / expectedDistance;
                
                return {
                    uniform: Math.exp(-clustering),
                    clustered: 1 - Math.exp(-clustering)
                };
            }

            computeModalCohomology(matches, text) {
                // COHOMOLOGICAL CONTRIBUTION OF MODAL ELEMENTS
                if (!matches.length) return 0;
                
                const strength = matches.length / text.split(/\s+/).length;
                const density = matches.length / text.length;
                const coherence = strength * density;
                
                return Math.min(1, coherence * 10);
            }

            evolveDynamic() {
                const flow = this.computeAdvancedFlow();
                const stability = this.computeDynamicStability();
                const emergence = this.computeEmergenceFactor();
                
                this.state.coherence = Math.max(0, Math.min(1, 
                    this.state.coherence + (Math.random() - 0.5) * 0.1 * this.context));
                
                const result = {
                    mode: 'continuous',
                    flow: flow,
                    stability: stability,
                    emergence: emergence,
                    coherence: this.state.coherence
                };
                
                this.displayContinuousResults(result);
                return result;
            }

            computeAdvancedFlow() {
                return {
                    velocity: this.state.velocity,
                    acceleration: Math.cos(this.time * 0.3) * this.context,
                    turbulence: Math.random() * 0.1,
                    vorticity: Math.sin(this.time * 0.4) * 0.2,
                    divergence: Math.cos(this.time * 0.6) * 0.15
                };
            }

            computeDynamicStability() {
                // STABILITY BASED ON MANIFOLD HISTORY
                this.manifoldHistory.push(this.state.coherence);
                if (this.manifoldHistory.length > 20) {
                    this.manifoldHistory.shift();
                }
                
                if (this.manifoldHistory.length < 3) return 0.5;
                
                const variance = this.variance(this.manifoldHistory);
                return Math.exp(-variance * 20);
            }

            hybridAnalysis(input) {
                // COMBINE DISCRETE AND CONTINUOUS ANALYSIS
                const discreteResult = this.analyzeCohomology(input);
                const continuousResult = this.evolveDynamic();
                
                const hybridCoherence = (discreteResult.coherence + continuousResult.coherence) / 2;
                this.state.coherence = hybridCoherence;
                
                const result = {
                    mode: 'hybrid',
                    discrete: discreteResult,
                    continuous: continuousResult,
                    hybridCoherence: hybridCoherence,
                    synthesis: this.computeSynthesis(discreteResult, continuousResult)
                };
                
                this.displayHybridResults(result);
                return result;
            }

            computeSynthesis(discrete, continuous) {
                return {
                    modalContinuity: discrete.modalities.cohomologicalDepth * continuous.flow.velocity,
                    emergentComplexity: discrete.structure.complexity * continuous.emergence,
                    cohomologicalFlow: discrete.coherence * continuous.stability
                };
            }

            displayCohomologyResults(result) {
                const resultsDiv = document.getElementById('results');
                
                resultsDiv.innerHTML = `
                    <strong>🧮 Cohomological Analysis:</strong><br>
                    <strong>Text:</strong> "${result.text}"<br>
                    <strong>Structure:</strong> ${result.structure.wordCount} words, complexity: ${result.structure.complexity.toFixed(3)}<br>
                    <strong>Cohomological Depth:</strong> ${result.modalities.cohomologicalDepth.toFixed(3)}<br>
                    <strong>Modal Coherence:</strong> ${result.modalities.modalCoherence.toFixed(3)}<br>
                    <strong>Topological Invariant:</strong> ${result.modalities.topologicalInvariant.toFixed(3)}<br>
                    <strong>Overall Coherence:</strong> ${result.coherence.toFixed(3)}<br>
                    <br>
                    <strong>Cohomological Invariants:</strong><br>
                    Betti Numbers: β₀=${result.cohomologicalInvariants.bettiNumbers.b0}, β₁=${result.cohomologicalInvariants.bettiNumbers.b1}, β₂=${result.cohomologicalInvariants.bettiNumbers.b2}<br>
                    Euler Characteristic: χ=${result.cohomologicalInvariants.eulerCharacteristic}<br>
                    <br>
                    <strong>Modal Elements:</strong><br>
                    ${Object.entries(result.modalities)
                        .filter(([k, v]) => typeof v === 'object' && v.count > 0)
                        .map(([k, v]) => `${k}: ${v.count} (${(v.strength * 100).toFixed(1)}%)`)
                        .join('<br>')}
                `;
            }

            displayContinuousResults(result) {
                const resultsDiv = document.getElementById('results');
                
                resultsDiv.innerHTML = `
                    <strong>🌊 Continuous Flow Analysis:</strong><br>
                    <strong>Flow Velocity:</strong> ${result.flow.velocity.toFixed(3)}<br>
                    <strong>Acceleration:</strong> ${result.flow.acceleration.toFixed(3)}<br>
                    <strong>Vorticity:</strong> ${result.flow.vorticity.toFixed(3)}<br>
                    <strong>Divergence:</strong> ${result.flow.divergence.toFixed(3)}<br>
                    <strong>Stability:</strong> ${result.stability.toFixed(3)}<br>
                    <strong>Emergence:</strong> ${result.emergence.toFixed(3)}<br>
                    <strong>Coherence:</strong> ${result.coherence.toFixed(3)}<br>
                    <strong>Turbulence:</strong> ${result.flow.turbulence.toFixed(3)}
                `;
            }

            displayHybridResults(result) {
                const resultsDiv = document.getElementById('results');
                
                resultsDiv.innerHTML = `
                    <strong>🔄 Hybrid Analysis:</strong><br>
                    <strong>Hybrid Coherence:</strong> ${result.hybridCoherence.toFixed(3)}<br>
                    <strong>Modal Continuity:</strong> ${result.synthesis.modalContinuity.toFixed(3)}<br>
                    <strong>Emergent Complexity:</strong> ${result.synthesis.emergentComplexity.toFixed(3)}<br>
                    <strong>Cohomological Flow:</strong> ${result.synthesis.cohomologicalFlow.toFixed(3)}<br>
                    <br>
                    <strong>Discrete Component:</strong> ${result.discrete.structure.wordCount} words, ${result.discrete.modalities.cohomologicalDepth.toFixed(3)} depth<br>
                    <strong>Continuous Component:</strong> velocity ${result.continuous.flow.velocity.toFixed(3)}, stability ${result.continuous.stability.toFixed(3)}
                `;
            }

            variance(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                return values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            }

            updateUI() {
                document.getElementById('coherence').textContent = this.state.coherence.toFixed(3);
                document.getElementById('depth').textContent = this.state.depth;
                document.getElementById('velocity').textContent = this.state.velocity.toFixed(2);
                document.getElementById('transfers').textContent = this.state.transfers;
                document.getElementById('emergence').textContent = this.state.emergence.toFixed(3);
            }

            modalTransfer() {
                this.state.transfers++;
                const oldCoherence = this.state.coherence;
                
                // ADVANCED MODAL TRANSFER WITH COHOMOLOGICAL DYNAMICS
                const transferStrength = this.context * 0.4;
                const cohomologicalInfluence = this.state.emergence * 0.3;
                const randomPerturbation = (Math.random() - 0.5) * 0.2;
                
                const totalPerturbation = (transferStrength + cohomologicalInfluence + randomPerturbation) * 
                    (Math.random() > 0.5 ? 1 : -1);
                
                this.state.coherence = Math.max(0, Math.min(1, oldCoherence + totalPerturbation));
                
                // TRIGGER VISUAL EFFECTS
                this.triggerTransferEffects();
                
                setStatus(`Modal Transfer: ${oldCoherence.toFixed(3)} → ${this.state.coherence.toFixed(3)}`);
                this.updateUI();
                
                return {
                    success: Math.abs(totalPerturbation) > 0.1,
                    magnitude: Math.abs(totalPerturbation),
                    direction: totalPerturbation > 0 ? 'expansion' : 'contraction'
                };
            }

            triggerTransferEffects() {
                // VISUAL EFFECTS FOR MODAL TRANSFER
                if (this.energySparks) {
                    // BRIGHTEN ENERGY SPARKS
                    this.energySparks.material.opacity = 1.0;
                    setTimeout(() => {
                        if (this.energySparks) {
                            this.energySparks.material.opacity = 0.9;
                        }
                    }, 1000);
                }
                
                // PULSE FLOW LINES
                this.flowLines.forEach(flow => {
                    const originalOpacity = flow.material.opacity;
                    flow.material.opacity = 1.0;
                    setTimeout(() => {
                        flow.material.opacity = originalOpacity;
                    }, 800);
                });
            }

            expandManifold() {
                // EXPAND THE COHOMOLOGICAL MANIFOLD
                if (this.manifold) {
                    const currentScale = this.manifold.scale.x;
                    const newScale = Math.min(currentScale * 1.2, 2.0);
                    
                    this.manifold.scale.setScalar(newScale);
                    
                    // INCREASE PARTICLE DENSITY
                    this.updateParticleDensity(this.density * 1.1);
                    
                    setStatus(`Manifold expanded to ${(newScale * 100).toFixed(0)}% scale`);
                }
            }

            updateParticleDensity(newDensity) {
                this.density = Math.min(newDensity, 2.0);
                document.getElementById('density-val').textContent = this.density.toFixed(1);
                
                // UPDATE PARTICLE SYSTEMS
                this.particleSystems.forEach(system => {
                    if (system.material) {
                        system.material.opacity = Math.min(1.0, 0.3 + this.density * 0.4);
                    }
                });
            }

            switchMode(mode) {
                this.mode = mode;
                setStatus(`Switched to ${mode} mode`);
                
                // ADJUST VISUAL PARAMETERS BASED ON MODE
                if (mode === 'discrete') {
                    this.speed = Math.min(this.speed, 1.5);
                } else if (mode === 'continuous') {
                    this.speed = Math.max(this.speed, 0.8);
                }
            }

            setContext(value) {
                this.context = parseFloat(value);
                document.getElementById('context-val').textContent = value;
                
                // UPDATE VISUAL SENSITIVITY
                this.particleSystems.forEach(system => {
                    if (system.material && system.material.size !== undefined) {
                        system.material.size = 2 + this.context * 4;
                    }
                });
            }

            setSpeed(value) {
                this.speed = parseFloat(value);
                document.getElementById('speed-val').textContent = value;
            }

            setDensity(value) {
                this.updateParticleDensity(parseFloat(value));
            }

            resetFlow() {
                this.state = { coherence: 0, depth: 0, velocity: 0, transfers: 0, emergence: 0 };
                this.manifoldHistory = [];
                this.cohomologyCache.clear();
                
                // RESET VISUAL ELEMENTS
                if (this.manifold) {
                    this.manifold.scale.setScalar(1.0);
                }
                
                this.updateUI();
                setStatus('Flow reset - all systems restored to initial state');
            }

            export() {
                return {
                    timestamp: new Date().toISOString(),
                    version: 'modal-consciousness-cohomology-1.0',
                    mode: this.mode,
                    context: this.context,
                    speed: this.speed,
                    density: this.density,
                    state: this.state,
                    manifoldHistory: this.manifoldHistory,
                    cohomologyCache: Array.from(this.cohomologyCache.entries()),
                    visualParameters: {
                        particleCount: this.consciousnessParticles ? this.consciousnessParticles.geometry.attributes.position.count : 0,
                        flowLineCount: this.flowLines.length,
                        energyFieldCount: this.energyFields.length
                    }
                };
            }
        }

        // GLOBAL ENGINE INSTANCE
        let engine;

        // UI FUNCTIONS - DIRECT AND FUNCTIONAL
        function processInput() {
            const text = document.getElementById('text-input').value.trim();
            if (!text) {
                setStatus('Enter text for cohomological analysis');
                return;
            }
            
            setStatus('Processing cohomological structures...');
            
            try {
                const result = engine.process(text);
                setStatus('Cohomological analysis complete');
                return result;
            } catch (error) {
                setStatus('Analysis error: ' + error.message);
                console.error('Processing error:', error);
            }
        }

        function switchMode() {
            const mode = document.getElementById('mode-select').value;
            engine.switchMode(mode);
        }

        function updateContext(value) {
            engine.setContext(value);
        }

        function updateSpeed(value) {
            engine.setSpeed(value);
        }

        function updateDensity(value) {
            engine.setDensity(value);
        }

        function modalTransfer() {
            const result = engine.modalTransfer();
            setStatus(`Modal transfer ${result.success ? 'successful' : 'minimal'} - ${result.direction} ${result.magnitude.toFixed(3)}`);
        }

        function expandManifold() {
            engine.expandManifold();
        }

        function resetFlow() {
            engine.resetFlow();
        }

        function setStatus(message) {
            document.getElementById('status').textContent = message;
            setTimeout(() => {
                document.getElementById('status').textContent = 'Modal Engine Ready';
            }, 4000);
        }

        // INITIALIZATION AND GLOBAL SETUP
        document.addEventListener('DOMContentLoaded', () => {
            try {
                setStatus('Initializing cohomological visualization...');
                
                engine = new ModalConsciousnessEngine();
                
                // Make engine globally available for console interaction
                window.modal = engine;
                window.cohomology = {
                    analyze: (text) => engine.process(text),
                    transfer: () => engine.modalTransfer(),
                    expand: () => engine.expandManifold(),
                    reset: () => engine.resetFlow(),
                    export: () => engine.export(),
                    state: () => engine.state,
                    help: () => console.log(`
🧮 Modal Consciousness Engine - Cohomological Interface:

ANALYSIS:
cohomology.analyze("text")     - Deep cohomological analysis
modal.process("text")          - Process with current mode

CONTROL:
cohomology.transfer()          - Force modal transfer
cohomology.expand()            - Expand manifold
cohomology.reset()             - Reset all systems

DATA:
cohomology.state()             - Current state
cohomology.export()            - Export full state

EXAMPLES:
cohomology.analyze("Consciousness necessarily emerges from the possible")
cohomology.analyze("If understanding must follow, then awareness possibly transcends")

The rich cohomological structures await your exploration...
                    `)
                };
                
                setStatus('Modal Engine Initialized - Cohomological Analysis Ready');
                
                console.log('🎯 Modal Consciousness Engine with Rich Cohomological Visualization Ready');
                console.log('✨ Features: Advanced 3D manifolds, particle systems, volumetric fog, energy fields');
                console.log('🧮 Try: cohomology.analyze("Consciousness must emerge from possibility and necessity")');
                
            } catch (error) {
                console.error('❌ Engine initialization failed:', error);
                setStatus('Initialization failed: ' + error.message);
            }
        });

        // RESPONSIVE HANDLING
        window.addEventListener('resize', () => {
            if (engine && engine.camera && engine.renderer) {
                engine.camera.aspect = window.innerWidth / window.innerHeight;
                engine.camera.updateProjectionMatrix();
                engine.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // CONSOLE SHORTCUTS FOR QUICK TESTING
        window.test = {
            cohomology: () => {
                document.getElementById('text-input').value = "If consciousness necessarily emerges from computation, then understanding must possibly follow from modal reasoning.";
                processInput();
            },
            continuous: () => {
                document.getElementById('mode-select').value = 'continuous';
                switchMode();
                engine.process({ dynamic: true });
            },
            hybrid: () => {
                document.getElementById('mode-select').value = 'hybrid';
                switchMode();
                document.getElementById('text-input').value = "Modal logic bridges discrete necessity and continuous possibility.";
                processInput();
            },
            visual: () => {
                modalTransfer();
                setTimeout(() => expandManifold(), 1000);
                setTimeout(() => modalTransfer(), 2000);
            },
            help: () => console.log(`
🎯 Quick Test Interface:

test.cohomology()  - Run cohomological analysis example
test.continuous()  - Test continuous flow mode
test.hybrid()      - Test hybrid analysis mode  
test.visual()      - Trigger visual effects sequence

cohomology.help()  - Full console interface
            `)
        };

        console.log(`
        ╔══════════════════════════════════════════════════════════════════════════════╗
        ║          MODAL CONSCIOUSNESS ENGINE - COHOMOLOGICAL VISUALIZATION           ║
        ║                           Advanced 3D Interface                              ║
        ╚══════════════════════════════════════════════════════════════════════════════╝
        
        🌊 RICH VISUAL FEATURES:
        • Cohomological manifolds with real mathematical structure
        • Multi-layered particle systems (consciousness, dust, sparks)
        • Volumetric fog and atmospheric effects
        • Dynamic flow fields representing modal transitions
        • Energy fields and rich textured surfaces
        
        🧮 ADVANCED ANALYSIS:
        • True cohomological depth computation
        • Betti numbers and topological invariants
        • Modal pattern recognition with 7 categories
        • Hybrid discrete/continuous processing
        
        🎯 READY FOR USE:
        Type text and click "Analyze Cohomology"
        Try: test.cohomology() or cohomology.help()
        `);
    </script>
</body>
</html>